<!-- -*- mode: jinja2 -*- -->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta name="description" content="lbfgsb optimization library">
    <meta name="author" content="Jacob Williams" >
    <link rel="icon" href="../favicon.png">

    <title>cauchy &ndash; lbfgsb</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <link href="../css/pygments.css" rel="stylesheet">
    <link href="../css/font-awesome.min.css" rel="stylesheet">
    <link href="../css/local.css" rel="stylesheet">
      <link  href="../tipuesearch/tipuesearch.css" rel="stylesheet">

    <script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
    <script src="../js/svg-pan-zoom.min.js"></script>
  </head>

  <body>

    <!-- Fixed navbar -->
    <div class="container-fluid mb-sm-4 mb-xl-2">
      <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
        <div class="container">
          <a class="navbar-brand" href="../index.html">lbfgsb </a>
          <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar"
                  aria-expanded="false" aria-controls="navbar" aria-label="Toggle navigation">
                  <span class="navbar-toggler-icon">
          </button>

          <div id="navbar" class="navbar-collapse collapse">
            <ul class="navbar-nav">
                  <li class="nav-item">
                    <a class="nav-link" href="../lists/files.html">Source Files</a>
                  </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/modules.html">Modules</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/procedures.html">Procedures</a>
                </li>
            </ul>
              <div class="d-flex align-items-end flex-grow-1">
                <form action="../search.html" role="search" class="ms-auto">
                  <input type="text" class="form-control" aria-label="Search" placeholder="Search" name="q" id="tipue_search_input" autocomplete="off" required>
                </form>
              </div>
          </div><!--/.nav-collapse -->
        </div>
      </nav>
    </div>

    <div class="container">
  <div class="row">
    <h1>cauchy
      <small>Subroutine</small>
      
    </h1>
      <div class="container p-2 mb-4 bg-light border rounded-3">
    <div class="row align-items-center justify-content-between" id="info-bar">
      <div class="col">
        <ul class="list-inline" style="margin-bottom:0px;display:inline">

            <li class="list-inline-item" id="statements"><i class="fa fa-list-ol"></i>
              <a data-bs-toggle="tooltip" data-bs-placement="bottom" data-bs-html="true"
                 title="10.9% of total for procedures.">218 statements</a>
            </li>

            <li class="list-inline-item" id="source-file">
              <i class="fa fa-code"></i>
              <a href="../src/lbfgsb.f90"> Source File</a>
            </li>
        </ul>
      </div>
      <div class="col">
        <nav aria-label="breadcrumb">
          <ol class="breadcrumb justify-content-end mb-0">
                <li class="breadcrumb-item"><a href='../sourcefile/lbfgsb.f90.html'>lbfgsb.f90</a></li>
                <li class="breadcrumb-item"><a href='../module/lbfgsb_module.html'>lbfgsb_module</a></li>
            <li class="breadcrumb-item active" aria-current="page">cauchy</li>
          </ol>
        </nav>
      </div>
    </div>
  </div>
  <script>
    $(function () {
    $('[data-bs-toggle="tooltip"]').tooltip()
    })
  </script>

  </div>
  
  <div class="row">
    <div class="col-md-3 hidden-xs hidden-sm visible-md visible-lg">
      <div id="sidebar">
      <h3>Contents</h3>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
    <div class="card card-primary">
      <div class="card-header text-left"><h3 class="card-title">Source Code</h3></div>
      <div class="list-group">
        <a class="list-group-item" href="../proc/cauchy.html#src">cauchy</a>
      </div>
    </div>


  </div>

    </div>
    
    <div class="col-md-9" id='text'>
    <h2>private  subroutine cauchy(n, x, l, u, Nbd, g, Iorder, Iwhere, t, d, Xcp, m, Wy, Ws, Sy, Wt, Theta, Col, Head, p, c, Wbp, v, Nseg, Iprint, Sbgnrm, Info, Epsmch)  
</h2>
    

    <p>For given <code>x</code>, <code>l</code>, <code>u</code>, <code>g</code> (with <code>sbgnrm &gt; 0</code>), and a limited memory
  BFGS matrix B defined in terms of matrices WY, WS, WT, and
  scalars head, col, and theta, this subroutine computes the
  generalized Cauchy point (GCP), defined as the first local
  minimizer of the quadratic</p>
<p><code>Q(x + s) = g's + 1/2 s'Bs</code></p>
<p>along the projected gradient direction <code>P(x-tg,l,u)</code>.
  The routine returns the GCP in <code>xcp</code>.</p>
<h3>References</h3>
<ol>
<li>R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, "A limited
     memory algorithm for bound constrained optimization",
     SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208.</li>
<li>C. Zhu, R.H. Byrd, P. Lu, J. Nocedal, "L-BFGS-B: FORTRAN
     Subroutines for Large Scale Bound Constrained Optimization"
     Tech. Report, NAM-11, EECS Department, Northwestern University,
     1994.</li>
</ol>
<h3>Credits</h3>
<ul>
<li>NEOS, November 1994. (Latest revision June 1996.)
    Optimization Technology Center.
    Argonne National Laboratory and Northwestern University.
    Written by Ciyou Zhu
    in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.</li>
</ul>


    <h3>Arguments</h3>
        <table class="table table-striped varlist">
    <thead>
      <tr>
        <th scope="col">Type</th>
<th scope="col">Intent</th><th scope="col">Optional</th>        <th scope="col">Attributes</th>
        <th scope="col"></th>
        <th scope="col">Name</th>
        <th scope="col"></th>
    </thead>
    <tbody>
        <tr>
            <td>
              <span class="anchor" id="variable-n~6"></span>
              integer,
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>n</strong></td>
            <td>
                <p>the dimension of the problem.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-x~4"></span>
              real(kind=wp),
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>x</strong>(n)</td>
            <td>
                <p>the starting point for the GCP computation.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-l~4"></span>
              real(kind=wp),
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>l</strong>(n)</td>
            <td>
                <p>the lower bound of <code>x</code>.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-u~4"></span>
              real(kind=wp),
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>u</strong>(n)</td>
            <td>
                <p>the upper bound of <code>x</code>.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-nbd~4"></span>
              integer,
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>Nbd</strong>(n)</td>
            <td>
                <p>On entry nbd represents the type of bounds imposed on the
variables, and must be specified as follows:</p>
<ul>
<li><code>nbd(i)=0</code> if <code>x(i)</code> is unbounded,</li>
<li><code>nbd(i)=1</code> if <code>x(i)</code> has only a lower bound,</li>
<li><code>nbd(i)=2</code> if <code>x(i)</code> has both lower and upper bounds, and</li>
<li><code>nbd(i)=3</code> if <code>x(i)</code> has only an upper bound.</li>
</ul>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-g~3"></span>
              real(kind=wp),
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>g</strong>(n)</td>
            <td>
                <p>the gradient of <code>f(x)</code>. <code>g</code> must be a nonzero vector.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-iorder"></span>
              integer
            </td>
<td></td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>Iorder</strong>(n)</td>
            <td>
                <p>working array used to store the breakpoints in the piecewise
linear path and free variables encountered. On exit:</p>
<ul>
<li><code>iorder(1),...,iorder(nleft)</code> are indices of breakpoints
   which have not been encountered;</li>
<li><code>iorder(nleft+1),...,iorder(nbreak)</code> are indices of
   encountered breakpoints; and</li>
<li><code>iorder(nfree),...,iorder(n)</code> are indices of variables which
   have no bound constraits along the search direction.</li>
</ul>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-iwhere~3"></span>
              integer,
            </td>
<td>intent(inout)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>Iwhere</strong>(n)</td>
            <td>
                <p>On entry <code>iwhere</code> indicates only the permanently fixed (<code>iwhere=3</code>)
or free (<code>iwhere= -1</code>) components of <code>x</code>.</p>
<p>On exit <code>iwhere</code> records the status of the current <code>x</code> variables:</p>
<ul>
<li><code>iwhere(i) = -3</code>  if <code>x(i)</code> is free and has bounds, but is not moved</li>
<li><code>iwhere(i) =  0</code> if <code>x(i)</code> is free and has bounds, and is moved</li>
<li><code>iwhere(i) =  1</code> if <code>x(i)</code> is fixed at l(i), and l(i) /= u(i)</li>
<li><code>iwhere(i) =  2</code> if <code>x(i)</code> is fixed at u(i), and u(i) /= l(i)</li>
<li><code>iwhere(i) =  3</code> if <code>x(i)</code> is always fixed, i.e.,  u(i)=x(i)=l(i)</li>
<li><code>iwhere(i) = -1</code>  if <code>x(i)</code> is always free, i.e., it has no bounds.</li>
</ul>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-t~4"></span>
              real(kind=wp)
            </td>
<td></td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>t</strong>(n)</td>
            <td>
                <p>used to store the break points.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-d~2"></span>
              real(kind=wp)
            </td>
<td></td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>d</strong>(n)</td>
            <td>
                <p>used to store the Cauchy direction <code>P(x-tg)-x</code>.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-xcp"></span>
              real(kind=wp),
            </td>
<td>intent(out)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>Xcp</strong>(n)</td>
            <td>
                <p>used to return the GCP on exit.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-m~4"></span>
              integer,
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>m</strong></td>
            <td>
                <p>the maximum number of variable metric corrections
used to define the limited memory matrix.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-wy~2"></span>
              real(kind=wp),
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>Wy</strong>(n,Col)</td>
            <td>
                <p>stores information that defines the limited memory BFGS matrix: <code>wy(n,m)</code> stores <code>Y</code>, a set of y-vectors;</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-ws~2"></span>
              real(kind=wp),
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>Ws</strong>(n,Col)</td>
            <td>
                <p>stores information that defines the limited memory BFGS matrix: <code>ws(n,m)</code> stores <code>S</code>, a set of s-vectors;</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-sy~3"></span>
              real(kind=wp),
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>Sy</strong>(m,m)</td>
            <td>
                <p>stores information that defines the limited memory BFGS matrix: <code>sy(m,m)</code> stores <code>S'Y</code>;</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-wt~3"></span>
              real(kind=wp),
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>Wt</strong>(m,m)</td>
            <td>
                <p>stores information that defines the limited memory BFGS matrix: <code>wt(m,m)</code> stores the Cholesky factorization of <code>(theta*S'S+LD^(-1)L')</code>.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-theta"></span>
              real(kind=wp),
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>Theta</strong></td>
            <td>
                <p>the scaling factor specifying <code>B_0 = theta I</code>.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-col~2"></span>
              integer,
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>Col</strong></td>
            <td>
                <p>the actual number of variable metric corrections stored so far.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-head"></span>
              integer,
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>Head</strong></td>
            <td>
                <p>the location of the first s-vector (or y-vector) in S (or Y).</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-p~2"></span>
              real(kind=wp)
            </td>
<td></td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>p</strong>(2*m)</td>
            <td>
                <p>working array used to store the vector <code>p = W^(T)d</code>.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-c"></span>
              real(kind=wp)
            </td>
<td></td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>c</strong>(2*m)</td>
            <td>
                <p>working array used to store the vector <code>c = W^(T)(xcp-x)</code>.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-wbp"></span>
              real(kind=wp)
            </td>
<td></td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>Wbp</strong>(2*m)</td>
            <td>
                <p>working array used to store the
row of <code>W</code> corresponding to a breakpoint.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-v~2"></span>
              real(kind=wp)
            </td>
<td></td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>v</strong>(2*m)</td>
            <td>
                <p>working array</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-nseg"></span>
              integer,
            </td>
<td>intent(out)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>Nseg</strong></td>
            <td>
                <p>records the number of quadratic segments explored
in searching for the GCP.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-iprint~4"></span>
              integer,
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>Iprint</strong></td>
            <td>
                <p>controls the frequency and type of output generated:</p>
<ul>
<li><code>iprint&lt;0</code> no output is generated;</li>
<li><code>iprint=0</code> print only one line at the last iteration;</li>
<li><code>0&lt;iprint&lt;99</code> print also f and |proj g| every iprint iterations;</li>
<li><code>iprint=99</code> print details of every iteration except n-vectors;</li>
<li><code>iprint=100</code> print also the changes of active set and final x;</li>
<li><code>iprint&gt;100</code> print details of every iteration including x and g;</li>
</ul>
<p>When <code>iprint &gt; 0</code>, the file <code>iterate.dat</code> will be created to
summarize the iteration.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-sbgnrm"></span>
              real(kind=wp),
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>Sbgnrm</strong></td>
            <td>
                <p>the norm of the projected gradient at <code>x</code>.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-info~2"></span>
              integer,
            </td>
<td>intent(inout)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>Info</strong></td>
            <td>
                <p>On entry info is 0.
On exit:</p>
<ul>
<li><code>info = 0</code>  for normal return,</li>
<li><code>info /= 0</code> for abnormal return when the system
    used in routine <a href="../proc/bmv.html">bmv</a> is singular.</li>
</ul>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-epsmch"></span>
              real(kind=wp),
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>Epsmch</strong></td>
            <td>
                <p>machine precision</p>
            </td>
        </tr>
    </tbody>
  </table>

    <br>
    <div class="card">
      <div class="card-header">
  <h3 class="card-title">Calls</h3>
      </div>
      <div class="card-body">
  <div class="depgraph"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: proc~~cauchy~~CallsGraph Pages: 1 -->
<svg id="proccauchyCallsGraph" width="332pt" height="223pt"
 viewBox="0.00 0.00 332.00 223.02" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="proc~~cauchy~~CallsGraph" class="graph" transform="scale(1 1) rotate(0) translate(4 219.02)">
<title>proc~~cauchy~~CallsGraph</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-219.02 328,-219.02 328,4 -4,4"/>
<!-- proc~cauchy -->
<g id="proc~~cauchy~~CallsGraph_node1" class="node">
<title>proc~cauchy</title>
<polygon fill="none" stroke="black" points="54,-126 0,-126 0,-102 54,-102 54,-126"/>
<text text-anchor="middle" x="27" y="-111.6" font-family="Helvetica,sans-Serif" font-size="10.50">cauchy</text>
</g>
<!-- proc~bmv -->
<g id="proc~~cauchy~~CallsGraph_node2" class="node">
<title>proc~bmv</title>
<g id="a_proc~~cauchy~~CallsGraph_node2"><a xlink:href="../proc/bmv.html" xlink:title="bmv">
<polygon fill="#d9534f" stroke="#d9534f" points="144,-188 90,-188 90,-164 144,-164 144,-188"/>
<text text-anchor="middle" x="117" y="-173.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">bmv</text>
</a>
</g>
</g>
<!-- proc~cauchy&#45;&gt;proc~bmv -->
<g id="proc~~cauchy~~CallsGraph_edge1" class="edge">
<title>proc~cauchy&#45;&gt;proc~bmv</title>
<path fill="none" stroke="#000000" d="M45.39,-126.25C58.24,-135.31 75.96,-147.79 90.43,-157.99"/>
<polygon fill="#000000" stroke="#000000" points="88.76,-161.09 98.95,-163.99 92.79,-155.37 88.76,-161.09"/>
</g>
<!-- proc~daxpy -->
<g id="proc~~cauchy~~CallsGraph_node3" class="node">
<title>proc~daxpy</title>
<g id="a_proc~~cauchy~~CallsGraph_node3"><a xlink:href="../proc/daxpy.html" xlink:title="daxpy">
<polygon fill="#d9534f" stroke="#d9534f" points="324,-208 270,-208 270,-184 324,-184 324,-208"/>
<text text-anchor="middle" x="297" y="-193.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">daxpy</text>
</a>
</g>
</g>
<!-- proc~cauchy&#45;&gt;proc~daxpy -->
<g id="proc~~cauchy~~CallsGraph_edge2" class="edge">
<title>proc~cauchy&#45;&gt;proc~daxpy</title>
<path fill="none" stroke="#000000" d="M32.8,-126.17C41.12,-145.38 60.25,-182.09 90,-197 144.2,-224.17 216.95,-214.92 259.92,-205.57"/>
<polygon fill="#000000" stroke="#000000" points="260.95,-208.92 269.91,-203.27 259.38,-202.1 260.95,-208.92"/>
</g>
<!-- proc~dcopy -->
<g id="proc~~cauchy~~CallsGraph_node4" class="node">
<title>proc~dcopy</title>
<g id="a_proc~~cauchy~~CallsGraph_node4"><a xlink:href="../proc/dcopy.html" xlink:title="dcopy">
<polygon fill="#d9534f" stroke="#d9534f" points="144,-146 90,-146 90,-122 144,-122 144,-146"/>
<text text-anchor="middle" x="117" y="-131.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">dcopy</text>
</a>
</g>
</g>
<!-- proc~cauchy&#45;&gt;proc~dcopy -->
<g id="proc~~cauchy~~CallsGraph_edge3" class="edge">
<title>proc~cauchy&#45;&gt;proc~dcopy</title>
<path fill="none" stroke="#000000" d="M54.4,-120C62.48,-121.84 71.51,-123.89 80.1,-125.84"/>
<polygon fill="#000000" stroke="#000000" points="79.39,-129.27 89.92,-128.07 80.94,-122.44 79.39,-129.27"/>
</g>
<!-- proc~ddot -->
<g id="proc~~cauchy~~CallsGraph_node5" class="node">
<title>proc~ddot</title>
<g id="a_proc~~cauchy~~CallsGraph_node5"><a xlink:href="../proc/ddot.html" xlink:title="ddot">
<polygon fill="#d94e8f" stroke="#d94e8f" points="324,-146 270,-146 270,-122 324,-122 324,-146"/>
<text text-anchor="middle" x="297" y="-131.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">ddot</text>
</a>
</g>
</g>
<!-- proc~cauchy&#45;&gt;proc~ddot -->
<g id="proc~~cauchy~~CallsGraph_edge4" class="edge">
<title>proc~cauchy&#45;&gt;proc~ddot</title>
<path fill="none" stroke="#000000" d="M54.24,-113.48C65.28,-113.29 78.27,-113.09 90,-113 114,-112.81 120.06,-111.35 144,-113 183.7,-115.73 228.83,-122.42 259.53,-127.53"/>
<polygon fill="#000000" stroke="#000000" points="259.31,-131.04 269.75,-129.26 260.48,-124.14 259.31,-131.04"/>
</g>
<!-- proc~dscal -->
<g id="proc~~cauchy~~CallsGraph_node6" class="node">
<title>proc~dscal</title>
<g id="a_proc~~cauchy~~CallsGraph_node6"><a xlink:href="../proc/dscal.html" xlink:title="dscal">
<polygon fill="#d9534f" stroke="#d9534f" points="144,-66 90,-66 90,-42 144,-42 144,-66"/>
<text text-anchor="middle" x="117" y="-51.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">dscal</text>
</a>
</g>
</g>
<!-- proc~cauchy&#45;&gt;proc~dscal -->
<g id="proc~~cauchy~~CallsGraph_edge5" class="edge">
<title>proc~cauchy&#45;&gt;proc~dscal</title>
<path fill="none" stroke="#000000" d="M45.81,-101.86C58.45,-93.24 75.63,-81.52 89.83,-71.84"/>
<polygon fill="#000000" stroke="#000000" points="91.93,-74.65 98.22,-66.12 87.98,-68.87 91.93,-74.65"/>
</g>
<!-- proc~hpsolb -->
<g id="proc~~cauchy~~CallsGraph_node7" class="node">
<title>proc~hpsolb</title>
<g id="a_proc~~cauchy~~CallsGraph_node7"><a xlink:href="../proc/hpsolb.html" xlink:title="hpsolb">
<polygon fill="#d9534f" stroke="#d9534f" points="144,-24 90,-24 90,0 144,0 144,-24"/>
<text text-anchor="middle" x="117" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">hpsolb</text>
</a>
</g>
</g>
<!-- proc~cauchy&#45;&gt;proc~hpsolb -->
<g id="proc~~cauchy~~CallsGraph_edge6" class="edge">
<title>proc~cauchy&#45;&gt;proc~hpsolb</title>
<path fill="none" stroke="#000000" d="M36.01,-101.75C47.1,-85.24 68.25,-55.33 90,-33 90.66,-32.33 91.33,-31.66 92.02,-30.99"/>
<polygon fill="#000000" stroke="#000000" points="94.65,-33.34 99.8,-24.09 90,-28.1 94.65,-33.34"/>
</g>
<!-- proc~dtrsl -->
<g id="proc~~cauchy~~CallsGraph_node8" class="node">
<title>proc~dtrsl</title>
<g id="a_proc~~cauchy~~CallsGraph_node8"><a xlink:href="../proc/dtrsl.html" xlink:title="dtrsl">
<polygon fill="#d9534f" stroke="#d9534f" points="234,-188 180,-188 180,-164 234,-164 234,-188"/>
<text text-anchor="middle" x="207" y="-173.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">dtrsl</text>
</a>
</g>
</g>
<!-- proc~bmv&#45;&gt;proc~dtrsl -->
<g id="proc~~cauchy~~CallsGraph_edge7" class="edge">
<title>proc~bmv&#45;&gt;proc~dtrsl</title>
<path fill="none" stroke="#000000" d="M144.4,-176C152.39,-176 161.31,-176 169.82,-176"/>
<polygon fill="#000000" stroke="#000000" points="169.92,-179.5 179.92,-176 169.92,-172.5 169.92,-179.5"/>
</g>
<!-- proc~dtrsl&#45;&gt;proc~daxpy -->
<g id="proc~~cauchy~~CallsGraph_edge8" class="edge">
<title>proc~dtrsl&#45;&gt;proc~daxpy</title>
<path fill="none" stroke="#000000" d="M234.4,-182C242.48,-183.84 251.51,-185.89 260.1,-187.84"/>
<polygon fill="#000000" stroke="#000000" points="259.39,-191.27 269.92,-190.07 260.94,-184.44 259.39,-191.27"/>
</g>
<!-- proc~dtrsl&#45;&gt;proc~ddot -->
<g id="proc~~cauchy~~CallsGraph_edge9" class="edge">
<title>proc~dtrsl&#45;&gt;proc~ddot</title>
<path fill="none" stroke="#000000" d="M233.45,-163.85C242.21,-159.67 252.17,-154.92 261.52,-150.46"/>
<polygon fill="#000000" stroke="#000000" points="263.09,-153.59 270.6,-146.12 260.07,-147.27 263.09,-153.59"/>
</g>
</g>
</svg>
</div>          <div>
            <a type="button" class="graph-help" data-bs-toggle="modal" href="#CallsGraph-help-text">Help</a>
          </div>
          <div class="modal fade" id="CallsGraph-help-text" tabindex="-1" role="dialog">
            <div class="modal-dialog modal-lg" role="document">
              <div class="modal-content">
                <div class="modal-header">
                  <h4 class="modal-title" id="-graph-help-label">Graph Key</h4>
                  <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
<p>Nodes of different colours represent the following: </p>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: Graph Key Pages: 1 -->
<svg width="641pt" height="28pt"
 viewBox="0.00 0.00 641.00 27.51" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(0.86 0.86) rotate(0) translate(4 28)">
<title>Graph Key</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-28 741.5,-28 741.5,4 -4,4"/>
<!-- Subroutine -->
<g id="node1" class="node">
<title>Subroutine</title>
<polygon fill="#d9534f" stroke="#d9534f" points="70,-24 0,-24 0,0 70,0 70,-24"/>
<text text-anchor="middle" x="35" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Subroutine</text>
</g>
<!-- Function -->
<g id="node2" class="node">
<title>Function</title>
<polygon fill="#d94e8f" stroke="#d94e8f" points="146,-24 88,-24 88,0 146,0 146,-24"/>
<text text-anchor="middle" x="117" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Function</text>
</g>
<!-- Interface -->
<g id="node3" class="node">
<title>Interface</title>
<polygon fill="#a7506f" stroke="#a7506f" points="225.5,-24 164.5,-24 164.5,0 225.5,0 225.5,-24"/>
<text text-anchor="middle" x="195" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Interface</text>
</g>
<!-- Type Bound Procedure -->
<g id="node4" class="node">
<title>Type Bound Procedure</title>
<polygon fill="#a7506f" stroke="#a7506f" points="374,-24 244,-24 244,0 374,0 374,-24"/>
<text text-anchor="middle" x="309" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Type Bound Procedure</text>
</g>
<!-- Unknown Procedure Type -->
<g id="node5" class="node">
<title>Unknown Procedure Type</title>
<polygon fill="#777777" stroke="#777777" points="537.5,-24 392.5,-24 392.5,0 537.5,0 537.5,-24"/>
<text text-anchor="middle" x="465" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Unknown Procedure Type</text>
</g>
<!-- Program -->
<g id="node6" class="node">
<title>Program</title>
<polygon fill="#f0ad4e" stroke="#f0ad4e" points="614,-24 556,-24 556,0 614,0 614,-24"/>
<text text-anchor="middle" x="585" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Program</text>
</g>
<!-- This Page&#39;s Entity -->
<g id="node7" class="node">
<title>This Page&#39;s Entity</title>
<polygon fill="none" stroke="black" points="737.5,-24 632.5,-24 632.5,0 737.5,0 737.5,-24"/>
<text text-anchor="middle" x="685" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50">This Page&#39;s Entity</text>
</g>
</g>
</svg>

<p>Solid arrows point from a procedure to one which it calls. Dashed 
arrows point from an interface to procedures which implement that interface.
This could include the module procedures in a generic interface or the
implementation in a submodule of an interface in a parent module.
</p>
 </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="card">
      <div class="card-header">
  <h3 class="card-title">Called by</h3>
      </div>
      <div class="card-body">
  <div class="depgraph"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: proc~~cauchy~~CalledByGraph Pages: 1 -->
<svg id="proccauchyCalledByGraph" width="242pt" height="32pt"
 viewBox="0.00 0.00 242.00 32.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="proc~~cauchy~~CalledByGraph" class="graph" transform="scale(1 1) rotate(0) translate(4 28)">
<title>proc~~cauchy~~CalledByGraph</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-28 238,-28 238,4 -4,4"/>
<!-- proc~cauchy -->
<g id="proc~~cauchy~~CalledByGraph_node1" class="node">
<title>proc~cauchy</title>
<polygon fill="none" stroke="black" points="234,-24 180,-24 180,0 234,0 234,-24"/>
<text text-anchor="middle" x="207" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50">cauchy</text>
</g>
<!-- proc~mainlb -->
<g id="proc~~cauchy~~CalledByGraph_node2" class="node">
<title>proc~mainlb</title>
<g id="a_proc~~cauchy~~CalledByGraph_node2"><a xlink:href="../proc/mainlb.html" xlink:title="mainlb">
<polygon fill="#d9534f" stroke="#d9534f" points="144,-24 90,-24 90,0 144,0 144,-24"/>
<text text-anchor="middle" x="117" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">mainlb</text>
</a>
</g>
</g>
<!-- proc~mainlb&#45;&gt;proc~cauchy -->
<g id="proc~~cauchy~~CalledByGraph_edge1" class="edge">
<title>proc~mainlb&#45;&gt;proc~cauchy</title>
<path fill="none" stroke="#000000" d="M144.4,-12C152.39,-12 161.31,-12 169.82,-12"/>
<polygon fill="#000000" stroke="#000000" points="169.92,-15.5 179.92,-12 169.92,-8.5 169.92,-15.5"/>
</g>
<!-- proc~setulb -->
<g id="proc~~cauchy~~CalledByGraph_node3" class="node">
<title>proc~setulb</title>
<g id="a_proc~~cauchy~~CalledByGraph_node3"><a xlink:href="../proc/setulb.html" xlink:title="setulb">
<polygon fill="#d9534f" stroke="#d9534f" points="54,-24 0,-24 0,0 54,0 54,-24"/>
<text text-anchor="middle" x="27" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">setulb</text>
</a>
</g>
</g>
<!-- proc~setulb&#45;&gt;proc~mainlb -->
<g id="proc~~cauchy~~CalledByGraph_edge2" class="edge">
<title>proc~setulb&#45;&gt;proc~mainlb</title>
<path fill="none" stroke="#000000" d="M54.4,-12C62.39,-12 71.31,-12 79.82,-12"/>
<polygon fill="#000000" stroke="#000000" points="79.92,-15.5 89.92,-12 79.92,-8.5 79.92,-15.5"/>
</g>
</g>
</svg>
</div>          <div>
            <a type="button" class="graph-help" data-bs-toggle="modal" href="#CalledByGraph-help-text">Help</a>
          </div>
          <div class="modal fade" id="CalledByGraph-help-text" tabindex="-1" role="dialog">
            <div class="modal-dialog modal-lg" role="document">
              <div class="modal-content">
                <div class="modal-header">
                  <h4 class="modal-title" id="-graph-help-label">Graph Key</h4>
                  <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
<p>Nodes of different colours represent the following: </p>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: Graph Key Pages: 1 -->
<svg width="641pt" height="28pt"
 viewBox="0.00 0.00 641.00 27.51" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(0.86 0.86) rotate(0) translate(4 28)">
<title>Graph Key</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-28 741.5,-28 741.5,4 -4,4"/>
<!-- Subroutine -->
<g id="node1" class="node">
<title>Subroutine</title>
<polygon fill="#d9534f" stroke="#d9534f" points="70,-24 0,-24 0,0 70,0 70,-24"/>
<text text-anchor="middle" x="35" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Subroutine</text>
</g>
<!-- Function -->
<g id="node2" class="node">
<title>Function</title>
<polygon fill="#d94e8f" stroke="#d94e8f" points="146,-24 88,-24 88,0 146,0 146,-24"/>
<text text-anchor="middle" x="117" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Function</text>
</g>
<!-- Interface -->
<g id="node3" class="node">
<title>Interface</title>
<polygon fill="#a7506f" stroke="#a7506f" points="225.5,-24 164.5,-24 164.5,0 225.5,0 225.5,-24"/>
<text text-anchor="middle" x="195" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Interface</text>
</g>
<!-- Type Bound Procedure -->
<g id="node4" class="node">
<title>Type Bound Procedure</title>
<polygon fill="#a7506f" stroke="#a7506f" points="374,-24 244,-24 244,0 374,0 374,-24"/>
<text text-anchor="middle" x="309" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Type Bound Procedure</text>
</g>
<!-- Unknown Procedure Type -->
<g id="node5" class="node">
<title>Unknown Procedure Type</title>
<polygon fill="#777777" stroke="#777777" points="537.5,-24 392.5,-24 392.5,0 537.5,0 537.5,-24"/>
<text text-anchor="middle" x="465" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Unknown Procedure Type</text>
</g>
<!-- Program -->
<g id="node6" class="node">
<title>Program</title>
<polygon fill="#f0ad4e" stroke="#f0ad4e" points="614,-24 556,-24 556,0 614,0 614,-24"/>
<text text-anchor="middle" x="585" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Program</text>
</g>
<!-- This Page&#39;s Entity -->
<g id="node7" class="node">
<title>This Page&#39;s Entity</title>
<polygon fill="none" stroke="black" points="737.5,-24 632.5,-24 632.5,0 737.5,0 737.5,-24"/>
<text text-anchor="middle" x="685" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50">This Page&#39;s Entity</text>
</g>
</g>
</svg>

<p>Solid arrows point from a procedure to one which it calls. Dashed 
arrows point from an interface to procedures which implement that interface.
This could include the module procedures in a generic interface or the
implementation in a submodule of an interface in a parent module.
</p>
 </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <br>


    
    

    
    



    
    <section>
    <h2><span class="anchor" id="src"></span>Source Code</h2>
    <div class="hl codehilite"><pre><span></span><span class="w">      </span><span class="k">subroutine </span><span class="n">cauchy</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">Nbd</span><span class="p">,</span><span class="n">g</span><span class="p">,</span><span class="n">Iorder</span><span class="p">,</span><span class="n">Iwhere</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">Xcp</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">Wy</span><span class="p">,</span><span class="n">Ws</span><span class="p">,</span><span class="n">Sy</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">                        </span><span class="n">Wt</span><span class="p">,</span><span class="n">Theta</span><span class="p">,</span><span class="n">Col</span><span class="p">,</span><span class="n">Head</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">Wbp</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">Nseg</span><span class="p">,</span><span class="n">Iprint</span><span class="p">,</span><span class="n">Sbgnrm</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">                        </span><span class="n">Info</span><span class="p">,</span><span class="n">Epsmch</span><span class="p">)</span>
<span class="w">      </span><span class="k">implicit none</span>


<span class="k">      </span><span class="kt">integer</span><span class="p">,</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="c">!! the dimension of the problem.</span>
<span class="w">      </span><span class="kt">integer</span><span class="p">,</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="c">!! the maximum number of variable metric corrections</span>
<span class="w">                              </span><span class="c">!! used to define the limited memory matrix.</span>
<span class="w">      </span><span class="kt">integer</span><span class="p">,</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">Head</span><span class="w"> </span><span class="c">!! the location of the first s-vector (or y-vector) in S (or Y).</span>
<span class="w">      </span><span class="kt">integer</span><span class="p">,</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">Col</span><span class="w"> </span><span class="c">!! the actual number of variable metric corrections stored so far.</span>
<span class="w">      </span><span class="kt">integer</span><span class="p">,</span><span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">Nseg</span><span class="w"> </span><span class="c">!! records the number of quadratic segments explored</span>
<span class="w">                                  </span><span class="c">!! in searching for the GCP.</span>
<span class="w">      </span><span class="kt">integer</span><span class="p">,</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">Iprint</span><span class="w"> </span><span class="c">!! controls the frequency and type of output generated:</span>
<span class="w">                                   </span><span class="c">!!</span>
<span class="w">                                   </span><span class="c">!!  * `iprint&lt;0   ` no output is generated;</span>
<span class="w">                                   </span><span class="c">!!  * `iprint=0   ` print only one line at the last iteration;</span>
<span class="w">                                   </span><span class="c">!!  * `0&lt;iprint&lt;99` print also f and |proj g| every iprint iterations;</span>
<span class="w">                                   </span><span class="c">!!  * `iprint=99  ` print details of every iteration except n-vectors;</span>
<span class="w">                                   </span><span class="c">!!  * `iprint=100 ` print also the changes of active set and final x;</span>
<span class="w">                                   </span><span class="c">!!  * `iprint&gt;100 ` print details of every iteration including x and g;</span>
<span class="w">                                   </span><span class="c">!!</span>
<span class="w">                                   </span><span class="c">!! When `iprint &gt; 0`, the file `iterate.dat` will be created to</span>
<span class="w">                                   </span><span class="c">!! summarize the iteration.</span>
<span class="w">      </span><span class="kt">integer</span><span class="p">,</span><span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">Info</span><span class="w"> </span><span class="c">!! On entry info is 0.</span>
<span class="w">                                    </span><span class="c">!! On exit:</span>
<span class="w">                                    </span><span class="c">!!</span>
<span class="w">                                    </span><span class="c">!!  * `info = 0`  for normal return,</span>
<span class="w">                                    </span><span class="c">!!  * `info /= 0` for abnormal return when the system</span>
<span class="w">                                    </span><span class="c">!!     used in routine [[bmv]] is singular.</span>
<span class="w">      </span><span class="kt">integer</span><span class="p">,</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">Nbd</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="c">!! On entry nbd represents the type of bounds imposed on the</span>
<span class="w">                                   </span><span class="c">!! variables, and must be specified as follows:</span>
<span class="w">                                   </span><span class="c">!!</span>
<span class="w">                                   </span><span class="c">!!  * `nbd(i)=0` if `x(i)` is unbounded,</span>
<span class="w">                                   </span><span class="c">!!  * `nbd(i)=1` if `x(i)` has only a lower bound,</span>
<span class="w">                                   </span><span class="c">!!  * `nbd(i)=2` if `x(i)` has both lower and upper bounds, and</span>
<span class="w">                                   </span><span class="c">!!  * `nbd(i)=3` if `x(i)` has only an upper bound.</span>
<span class="w">      </span><span class="kt">integer</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">Iorder</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="c">!! working array used to store the breakpoints in the piecewise</span>
<span class="w">                           </span><span class="c">!! linear path and free variables encountered. On exit:</span>
<span class="w">                           </span><span class="c">!!</span>
<span class="w">                           </span><span class="c">!!  * `iorder(1),...,iorder(nleft)` are indices of breakpoints</span>
<span class="w">                           </span><span class="c">!!    which have not been encountered;</span>
<span class="w">                           </span><span class="c">!!  * `iorder(nleft+1),...,iorder(nbreak)` are indices of</span>
<span class="w">                           </span><span class="c">!!    encountered breakpoints; and</span>
<span class="w">                           </span><span class="c">!!  * `iorder(nfree),...,iorder(n)` are indices of variables which</span>
<span class="w">                           </span><span class="c">!!    have no bound constraits along the search direction.</span>
<span class="w">      </span><span class="kt">integer</span><span class="p">,</span><span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">Iwhere</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="c">!! On entry `iwhere` indicates only the permanently fixed (`iwhere=3`)</span>
<span class="w">                                         </span><span class="c">!! or free (`iwhere= -1`) components of `x`.</span>
<span class="w">                                         </span><span class="c">!!</span>
<span class="w">                                         </span><span class="c">!! On exit `iwhere` records the status of the current `x` variables:</span>
<span class="w">                                         </span><span class="c">!!</span>
<span class="w">                                         </span><span class="c">!!  * `iwhere(i) = -3`  if `x(i)` is free and has bounds, but is not moved</span>
<span class="w">                                         </span><span class="c">!!  * `iwhere(i) =  0 ` if `x(i)` is free and has bounds, and is moved</span>
<span class="w">                                         </span><span class="c">!!  * `iwhere(i) =  1 ` if `x(i)` is fixed at l(i), and l(i) /= u(i)</span>
<span class="w">                                         </span><span class="c">!!  * `iwhere(i) =  2 ` if `x(i)` is fixed at u(i), and u(i) /= l(i)</span>
<span class="w">                                         </span><span class="c">!!  * `iwhere(i) =  3 ` if `x(i)` is always fixed, i.e.,  u(i)=x(i)=l(i)</span>
<span class="w">                                         </span><span class="c">!!  * `iwhere(i) = -1`  if `x(i)` is always free, i.e., it has no bounds.</span>
<span class="w">      </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">Theta</span><span class="w"> </span><span class="c">!! the scaling factor specifying `B_0 = theta I`.</span>
<span class="w">      </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">Epsmch</span><span class="w"> </span><span class="c">!! machine precision</span>
<span class="w">      </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="c">!! the starting point for the GCP computation.</span>
<span class="w">      </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">l</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="c">!! the lower bound of `x`.</span>
<span class="w">      </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">u</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="c">!! the upper bound of `x`.</span>
<span class="w">      </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="c">!! the gradient of `f(x)`. `g` must be a nonzero vector.</span>
<span class="w">      </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">t</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="c">!! used to store the break points.</span>
<span class="w">      </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">d</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="c">!! used to store the Cauchy direction `P(x-tg)-x`.</span>
<span class="w">      </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">Xcp</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="c">!! used to return the GCP on exit.</span>
<span class="w">      </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">Wy</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">Col</span><span class="p">)</span><span class="w"> </span><span class="c">!! stores information that defines the limited memory BFGS matrix: `wy(n,m)` stores `Y`, a set of y-vectors;</span>
<span class="w">      </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">Ws</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">Col</span><span class="p">)</span><span class="w"> </span><span class="c">!! stores information that defines the limited memory BFGS matrix: `ws(n,m)` stores `S`, a set of s-vectors;</span>
<span class="w">      </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">Sy</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="c">!! stores information that defines the limited memory BFGS matrix: `sy(m,m)` stores `S&#39;Y`;</span>
<span class="w">      </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">Wt</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="c">!! stores information that defines the limited memory BFGS matrix: `wt(m,m)` stores the Cholesky factorization of `(theta*S&#39;S+LD^(-1)L&#39;)`.</span>
<span class="w">      </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="c">!! working array used to store the vector `p = W^(T)d`.</span>
<span class="w">      </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">c</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="c">!! working array used to store the vector `c = W^(T)(xcp-x)`.</span>
<span class="w">      </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">Wbp</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="c">!! working array used to store the</span>
<span class="w">                           </span><span class="c">!! row of `W` corresponding to a breakpoint.</span>
<span class="w">      </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">v</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="c">!! working array</span>
<span class="w">      </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">Sbgnrm</span><span class="w"> </span><span class="c">!! the norm of the projected gradient at `x`.</span>

<span class="w">      </span><span class="kt">logical</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">xlower</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">xupper</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">bnded</span>
<span class="w">      </span><span class="kt">integer</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">col2</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">nfree</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">nbreak</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">pointr</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">ibp</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">nleft</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">                 </span><span class="n">ibkmin</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">iter</span>
<span class="w">      </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">f2</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">dt</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">dtm</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">tsum</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">dibp</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">zibp</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">dibp2</span><span class="w"> </span><span class="p">,&amp;</span>
<span class="w">                  </span><span class="n">bkmin</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">tu</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">wmc</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">wmp</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">wmw</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">tj</span><span class="w"> </span><span class="p">,</span><span class="w">  </span><span class="p">&amp;</span>
<span class="w">                  </span><span class="n">tj0</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">neggi</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">f2_org</span>

<span class="w">      </span><span class="c">! Check the status of the variables, reset iwhere(i) if necessary;</span>
<span class="w">      </span><span class="c">! compute the Cauchy direction d and the breakpoints t; initialize</span>
<span class="w">      </span><span class="c">! the derivative f1 and the vector p = W&#39;d (for theta = 1).</span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Sbgnrm</span><span class="o">&lt;=</span><span class="n">zero</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="k">         if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Iprint</span><span class="o">&gt;=</span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">write</span><span class="w"> </span><span class="p">(</span><span class="n">output_unit</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="s1">&#39;Subgnorm = 0.  GCP = X.&#39;</span>
<span class="w">         </span><span class="k">call </span><span class="n">dcopy</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">Xcp</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="w">         </span><span class="k">return</span>
<span class="k">      endif</span>
<span class="k">      </span><span class="n">bnded</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="n">true</span><span class="p">.</span>
<span class="w">      </span><span class="n">nfree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">      </span><span class="n">nbreak</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">      </span><span class="n">ibkmin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">      </span><span class="n">bkmin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zero</span>
<span class="w">      </span><span class="n">col2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="n">Col</span>
<span class="w">      </span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zero</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Iprint</span><span class="o">&gt;=</span><span class="mi">99</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">write</span><span class="w"> </span><span class="p">(</span><span class="n">output_unit</span><span class="p">,</span><span class="s1">&#39;(/,a)&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">            </span><span class="s1">&#39;---------------- CAUCHY entered-------------------&#39;</span>

<span class="w">      </span><span class="c">! We set p to zero and build it up as we determine d.</span>

<span class="w">      </span><span class="k">do </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">col2</span>
<span class="w">         </span><span class="n">p</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zero</span>
<span class="w">      </span><span class="k">enddo</span>

<span class="w">      </span><span class="c">! In the following loop we determine for each variable its bound</span>
<span class="w">      </span><span class="c">! status and its breakpoint, and update p accordingly.</span>
<span class="w">      </span><span class="c">! Smallest breakpoint is identified.</span>

<span class="w">      </span><span class="k">do </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">n</span>
<span class="w">         </span><span class="n">neggi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">g</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="w">         </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Iwhere</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">/=</span><span class="mi">3</span><span class="w"> </span><span class="p">.</span><span class="nb">and</span><span class="p">.</span><span class="w"> </span><span class="n">Iwhere</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">/=-</span><span class="mi">1</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="w">            </span><span class="c">! if x(i) is not a constant and has bounds,</span>
<span class="w">            </span><span class="c">! compute the difference between x(i) and its bounds.</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Nbd</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">2</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">tl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">l</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Nbd</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">2</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">tu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="w">            </span><span class="c">! If a variable is close enough to a bound</span>
<span class="w">            </span><span class="c">! we treat it as at bound.</span>
<span class="w">            </span><span class="n">xlower</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Nbd</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">2</span><span class="w"> </span><span class="p">.</span><span class="nb">and</span><span class="p">.</span><span class="w"> </span><span class="n">tl</span><span class="o">&lt;=</span><span class="n">zero</span>
<span class="w">            </span><span class="n">xupper</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Nbd</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">2</span><span class="w"> </span><span class="p">.</span><span class="nb">and</span><span class="p">.</span><span class="w"> </span><span class="n">tu</span><span class="o">&lt;=</span><span class="n">zero</span>

<span class="w">            </span><span class="c">! reset iwhere(i).</span>
<span class="w">            </span><span class="n">Iwhere</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">xlower</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="k">               if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">neggi</span><span class="o">&lt;=</span><span class="n">zero</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">Iwhere</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">            </span><span class="k">else if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">xupper</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="k">               if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">neggi</span><span class="o">&gt;=</span><span class="n">zero</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">Iwhere</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span>
<span class="w">            </span><span class="k">else</span>
<span class="k">               if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nb">abs</span><span class="p">(</span><span class="n">neggi</span><span class="p">)</span><span class="o">&lt;=</span><span class="n">zero</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">Iwhere</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">3</span>
<span class="w">            </span><span class="k">endif</span>
<span class="k">         endif</span>
<span class="k">         </span><span class="n">pointr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Head</span>
<span class="w">         </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Iwhere</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">/=</span><span class="mi">0</span><span class="w"> </span><span class="p">.</span><span class="nb">and</span><span class="p">.</span><span class="w"> </span><span class="n">Iwhere</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">/=-</span><span class="mi">1</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="k">            </span><span class="n">d</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zero</span>
<span class="w">         </span><span class="k">else</span>
<span class="k">            </span><span class="n">d</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">neggi</span>
<span class="w">            </span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">neggi</span><span class="o">*</span><span class="n">neggi</span>
<span class="w">            </span><span class="c">! calculate p := p - W&#39;e_i* (g_i).</span>
<span class="w">            </span><span class="k">do </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">Col</span>
<span class="w">               </span><span class="n">p</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Wy</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">pointr</span><span class="p">)</span><span class="o">*</span><span class="n">neggi</span>
<span class="w">               </span><span class="n">p</span><span class="p">(</span><span class="n">Col</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="n">Col</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Ws</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">pointr</span><span class="p">)</span><span class="o">*</span><span class="n">neggi</span>
<span class="w">               </span><span class="n">pointr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">mod</span><span class="p">(</span><span class="n">pointr</span><span class="p">,</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">            </span><span class="k">enddo</span>
<span class="k">            if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Nbd</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">2</span><span class="w"> </span><span class="p">.</span><span class="nb">and</span><span class="p">.</span><span class="w"> </span><span class="n">Nbd</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">/=</span><span class="mi">0</span><span class="w"> </span><span class="p">.</span><span class="nb">and</span><span class="p">.</span><span class="w"> </span><span class="n">neggi</span><span class="o">&lt;</span><span class="n">zero</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="w">               </span><span class="c">! x(i) + d(i) is bounded; compute t(i).</span>
<span class="w">               </span><span class="n">nbreak</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nbreak</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">               </span><span class="n">Iorder</span><span class="p">(</span><span class="n">nbreak</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span>
<span class="w">               </span><span class="n">t</span><span class="p">(</span><span class="n">nbreak</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tl</span><span class="o">/</span><span class="p">(</span><span class="o">-</span><span class="n">neggi</span><span class="p">)</span>
<span class="w">               </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">nbreak</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="p">.</span><span class="nb">or</span><span class="p">.</span><span class="w"> </span><span class="n">t</span><span class="p">(</span><span class="n">nbreak</span><span class="p">)</span><span class="o">&lt;</span><span class="n">bkmin</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="k">                  </span><span class="n">bkmin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">(</span><span class="n">nbreak</span><span class="p">)</span>
<span class="w">                  </span><span class="n">ibkmin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nbreak</span>
<span class="w">               </span><span class="k">endif</span>
<span class="k">            else if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Nbd</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">2</span><span class="w"> </span><span class="p">.</span><span class="nb">and</span><span class="p">.</span><span class="w"> </span><span class="n">neggi</span><span class="o">&gt;</span><span class="n">zero</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="w">               </span><span class="c">! x(i) + d(i) is bounded; compute t(i).</span>
<span class="w">               </span><span class="n">nbreak</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nbreak</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">               </span><span class="n">Iorder</span><span class="p">(</span><span class="n">nbreak</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span>
<span class="w">               </span><span class="n">t</span><span class="p">(</span><span class="n">nbreak</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tu</span><span class="o">/</span><span class="n">neggi</span>
<span class="w">               </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">nbreak</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="p">.</span><span class="nb">or</span><span class="p">.</span><span class="w"> </span><span class="n">t</span><span class="p">(</span><span class="n">nbreak</span><span class="p">)</span><span class="o">&lt;</span><span class="n">bkmin</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="k">                  </span><span class="n">bkmin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">(</span><span class="n">nbreak</span><span class="p">)</span>
<span class="w">                  </span><span class="n">ibkmin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nbreak</span>
<span class="w">               </span><span class="k">endif</span>
<span class="k">            else</span>
<span class="w">               </span><span class="c">! x(i) + d(i) is not bounded.</span>
<span class="w">               </span><span class="n">nfree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nfree</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span>
<span class="w">               </span><span class="n">Iorder</span><span class="p">(</span><span class="n">nfree</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span>
<span class="w">               </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nb">abs</span><span class="p">(</span><span class="n">neggi</span><span class="p">)</span><span class="o">&gt;</span><span class="n">zero</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">bnded</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="n">false</span><span class="p">.</span>
<span class="w">            </span><span class="k">endif</span>
<span class="k">         endif</span>
<span class="k">      enddo</span>

<span class="w">      </span><span class="c">! The indices of the nonzero components of d are now stored</span>
<span class="w">      </span><span class="c">! in iorder(1),...,iorder(nbreak) and iorder(nfree),...,iorder(n).</span>
<span class="w">      </span><span class="c">! The smallest of the nbreak breakpoints is in t(ibkmin)=bkmin.</span>

<span class="w">      </span><span class="c">! complete the initialization of p for theta not= one.</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Theta</span><span class="o">/=</span><span class="n">one</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">call </span><span class="n">dscal</span><span class="p">(</span><span class="n">Col</span><span class="p">,</span><span class="n">Theta</span><span class="p">,</span><span class="n">p</span><span class="p">(</span><span class="n">Col</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>

<span class="w">      </span><span class="c">! Initialize GCP xcp = x.</span>

<span class="w">      </span><span class="k">call </span><span class="n">dcopy</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">Xcp</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">nbreak</span><span class="o">==</span><span class="mi">0</span><span class="w"> </span><span class="p">.</span><span class="nb">and</span><span class="p">.</span><span class="w"> </span><span class="n">nfree</span><span class="o">==</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="w">         </span><span class="c">! is a zero vector, return with the initial xcp as GCP.</span>
<span class="w">         </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Iprint</span><span class="o">&gt;</span><span class="mi">100</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">write</span><span class="w"> </span><span class="p">(</span><span class="n">output_unit</span><span class="p">,</span><span class="s1">&#39;(A,/,(4x,1p,6(1x,d11.4)))&#39;</span><span class="p">)</span><span class="w"> </span><span class="s1">&#39;Cauchy X =  &#39;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">Xcp</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
<span class="w">         </span><span class="k">return</span>
<span class="k">      endif</span>

<span class="w">      </span><span class="c">! Initialize c = W&#39;(xcp - x) = 0.</span>

<span class="w">      </span><span class="k">do </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">col2</span>
<span class="w">         </span><span class="n">c</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zero</span>
<span class="w">      </span><span class="k">enddo</span>

<span class="w">      </span><span class="c">! Initialize derivative f2.</span>

<span class="w">      </span><span class="n">f2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">Theta</span><span class="o">*</span><span class="n">f1</span>
<span class="w">      </span><span class="n">f2_org</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f2</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Col</span><span class="o">&gt;</span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="k">         call </span><span class="n">bmv</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">Sy</span><span class="p">,</span><span class="n">Wt</span><span class="p">,</span><span class="n">Col</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">Info</span><span class="p">)</span>
<span class="w">         </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Info</span><span class="o">/=</span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">return</span>
<span class="k">         </span><span class="n">f2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ddot</span><span class="p">(</span><span class="n">col2</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="w">      </span><span class="k">endif</span>
<span class="k">      </span><span class="n">dtm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">f1</span><span class="o">/</span><span class="n">f2</span>
<span class="w">      </span><span class="n">tsum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zero</span>
<span class="w">      </span><span class="n">Nseg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Iprint</span><span class="o">&gt;=</span><span class="mi">99</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">write</span><span class="w"> </span><span class="p">(</span><span class="n">output_unit</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="s1">&#39;There are &#39;</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">nbreak</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;  breakpoints &#39;</span>

<span class="w">      </span><span class="c">! If there are no breakpoints, locate the GCP and return.</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">nbreak</span><span class="o">/=</span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">then</span>

<span class="k">         </span><span class="n">nleft</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nbreak</span>
<span class="w">         </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>

<span class="w">         </span><span class="n">tj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zero</span>

<span class="w">         </span><span class="c">!------------------- the beginning of the loop -------------------------</span>
<span class="w">         </span><span class="n">main</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="k">do</span>

<span class="w">            </span><span class="c">! Find the next smallest breakpoint;</span>
<span class="w">            </span><span class="c">! compute dt = t(nleft) - t(nleft + 1).</span>

<span class="w">            </span><span class="n">tj0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tj</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">iter</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="w">               </span><span class="c">! Since we already have the smallest breakpoint we need not do</span>
<span class="w">               </span><span class="c">! heapsort yet. Often only one breakpoint is used and the</span>
<span class="w">               </span><span class="c">! cost of heapsort is avoided.</span>
<span class="w">               </span><span class="n">tj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bkmin</span>
<span class="w">               </span><span class="n">ibp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Iorder</span><span class="p">(</span><span class="n">ibkmin</span><span class="p">)</span>
<span class="w">            </span><span class="k">else</span>
<span class="k">               if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">iter</span><span class="o">==</span><span class="mi">2</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="w">                  </span><span class="c">! Replace the already used smallest breakpoint with the</span>
<span class="w">                  </span><span class="c">! breakpoint numbered nbreak &gt; nlast, before heapsort call.</span>
<span class="w">                  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">ibkmin</span><span class="o">/=</span><span class="n">nbreak</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="k">                     </span><span class="n">t</span><span class="p">(</span><span class="n">ibkmin</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">(</span><span class="n">nbreak</span><span class="p">)</span>
<span class="w">                     </span><span class="n">Iorder</span><span class="p">(</span><span class="n">ibkmin</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Iorder</span><span class="p">(</span><span class="n">nbreak</span><span class="p">)</span>
<span class="w">                  </span><span class="k">endif</span>
<span class="w">                  </span><span class="c">! Update heap structure of breakpoints</span>
<span class="w">                  </span><span class="c">! (if iter=2, initialize heap).</span>
<span class="w">               </span><span class="k">endif</span>
<span class="k">               call </span><span class="n">hpsolb</span><span class="p">(</span><span class="n">nleft</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">Iorder</span><span class="p">,</span><span class="n">iter</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="w">               </span><span class="n">tj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">(</span><span class="n">nleft</span><span class="p">)</span>
<span class="w">               </span><span class="n">ibp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Iorder</span><span class="p">(</span><span class="n">nleft</span><span class="p">)</span>
<span class="w">            </span><span class="k">endif</span>

<span class="k">            </span><span class="n">dt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tj</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">tj0</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">dt</span><span class="o">/=</span><span class="n">zero</span><span class="w"> </span><span class="p">.</span><span class="nb">and</span><span class="p">.</span><span class="w"> </span><span class="n">Iprint</span><span class="o">&gt;=</span><span class="mi">100</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="k">               write</span><span class="w"> </span><span class="p">(</span><span class="n">output_unit</span><span class="p">,</span><span class="s1">&#39;(/,a,i3,a,1p,2(1x,d11.4))&#39;</span><span class="p">)</span><span class="w"> </span><span class="s1">&#39;Piece    &#39;</span><span class="p">,</span><span class="w"> </span><span class="n">Nseg</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39; --f1, f2 at start point &#39;</span><span class="p">,</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">f2</span>
<span class="w">               </span><span class="k">write</span><span class="w"> </span><span class="p">(</span><span class="n">output_unit</span><span class="p">,</span><span class="s1">&#39;(a,1p,d11.4)&#39;</span><span class="p">)</span><span class="w"> </span><span class="s1">&#39;Distance to the next break point =  &#39;</span><span class="p">,</span><span class="w"> </span><span class="n">dt</span>
<span class="w">               </span><span class="k">write</span><span class="w"> </span><span class="p">(</span><span class="n">output_unit</span><span class="p">,</span><span class="s1">&#39;(A,1p,d11.4)&#39;</span><span class="p">)</span><span class="w"> </span><span class="s1">&#39;Distance to the stationary point =  &#39;</span><span class="p">,</span><span class="n">dtm</span>
<span class="w">            </span><span class="k">endif</span>

<span class="w">            </span><span class="c">! If a minimizer is within this interval, locate the GCP and return.</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">dtm</span><span class="o">&lt;</span><span class="n">dt</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">exit </span><span class="n">main</span>

<span class="w">            </span><span class="c">! Otherwise fix one variable and</span>
<span class="w">            </span><span class="c">! reset the corresponding component of d to zero.</span>

<span class="w">            </span><span class="n">tsum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tsum</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dt</span>
<span class="w">            </span><span class="n">nleft</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nleft</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span>
<span class="w">            </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">            </span><span class="n">dibp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="p">(</span><span class="n">ibp</span><span class="p">)</span>
<span class="w">            </span><span class="n">d</span><span class="p">(</span><span class="n">ibp</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zero</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">dibp</span><span class="o">&gt;</span><span class="n">zero</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="k">               </span><span class="n">zibp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">(</span><span class="n">ibp</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">ibp</span><span class="p">)</span>
<span class="w">               </span><span class="n">Xcp</span><span class="p">(</span><span class="n">ibp</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">(</span><span class="n">ibp</span><span class="p">)</span>
<span class="w">               </span><span class="n">Iwhere</span><span class="p">(</span><span class="n">ibp</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span>
<span class="w">            </span><span class="k">else</span>
<span class="k">               </span><span class="n">zibp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="p">(</span><span class="n">ibp</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">ibp</span><span class="p">)</span>
<span class="w">               </span><span class="n">Xcp</span><span class="p">(</span><span class="n">ibp</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="p">(</span><span class="n">ibp</span><span class="p">)</span>
<span class="w">               </span><span class="n">Iwhere</span><span class="p">(</span><span class="n">ibp</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">            </span><span class="k">endif</span>
<span class="k">            if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Iprint</span><span class="o">&gt;=</span><span class="mi">100</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">write</span><span class="w"> </span><span class="p">(</span><span class="n">output_unit</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="s1">&#39;Variable  &#39;</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">ibp</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;  is fixed.&#39;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">nleft</span><span class="o">==</span><span class="mi">0</span><span class="w"> </span><span class="p">.</span><span class="nb">and</span><span class="p">.</span><span class="w"> </span><span class="n">nbreak</span><span class="o">==</span><span class="n">n</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="w">               </span><span class="c">! all n variables are fixed,</span>
<span class="w">               </span><span class="c">! return with xcp as GCP.</span>
<span class="w">               </span><span class="n">dtm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dt</span>
<span class="w">               </span><span class="k">call </span><span class="n">update</span><span class="p">()</span>
<span class="w">               </span><span class="k">return</span>
<span class="k">            endif</span>

<span class="w">            </span><span class="c">! Update the derivative information.</span>

<span class="w">            </span><span class="n">Nseg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Nseg</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">            </span><span class="n">dibp2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dibp</span><span class="o">**</span><span class="mi">2</span>

<span class="w">            </span><span class="c">! Update f1 and f2.</span>

<span class="w">            </span><span class="c">! temporarily set f1 and f2 for col=0.</span>
<span class="w">            </span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dt</span><span class="o">*</span><span class="n">f2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dibp2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">Theta</span><span class="o">*</span><span class="n">dibp</span><span class="o">*</span><span class="n">zibp</span>
<span class="w">            </span><span class="n">f2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">Theta</span><span class="o">*</span><span class="n">dibp2</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Col</span><span class="o">&gt;</span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="w">               </span><span class="c">! update c = c + dt*p.</span>
<span class="w">               </span><span class="k">call </span><span class="n">daxpy</span><span class="p">(</span><span class="n">col2</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="w">               </span><span class="c">! choose wbp,</span>
<span class="w">               </span><span class="c">! the row of W corresponding to the breakpoint encountered.</span>
<span class="w">               </span><span class="n">pointr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Head</span>
<span class="w">               </span><span class="k">do </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">Col</span>
<span class="w">                  </span><span class="n">Wbp</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Wy</span><span class="p">(</span><span class="n">ibp</span><span class="p">,</span><span class="n">pointr</span><span class="p">)</span>
<span class="w">                  </span><span class="n">Wbp</span><span class="p">(</span><span class="n">Col</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Theta</span><span class="o">*</span><span class="n">Ws</span><span class="p">(</span><span class="n">ibp</span><span class="p">,</span><span class="n">pointr</span><span class="p">)</span>
<span class="w">                  </span><span class="n">pointr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">mod</span><span class="p">(</span><span class="n">pointr</span><span class="p">,</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">               </span><span class="k">enddo</span>

<span class="w">               </span><span class="c">! compute (wbp)Mc, (wbp)Mp, and (wbp)M(wbp)&#39;.</span>
<span class="w">               </span><span class="k">call </span><span class="n">bmv</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">Sy</span><span class="p">,</span><span class="n">Wt</span><span class="p">,</span><span class="n">Col</span><span class="p">,</span><span class="n">Wbp</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">Info</span><span class="p">)</span>
<span class="w">               </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Info</span><span class="o">/=</span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">return</span>
<span class="k">               </span><span class="n">wmc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ddot</span><span class="p">(</span><span class="n">col2</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="w">               </span><span class="n">wmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ddot</span><span class="p">(</span><span class="n">col2</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="w">               </span><span class="n">wmw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ddot</span><span class="p">(</span><span class="n">col2</span><span class="p">,</span><span class="n">Wbp</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="w">               </span><span class="c">! update p = p - dibp*wbp.</span>
<span class="w">               </span><span class="k">call </span><span class="n">daxpy</span><span class="p">(</span><span class="n">col2</span><span class="p">,</span><span class="o">-</span><span class="n">dibp</span><span class="p">,</span><span class="n">Wbp</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="w">               </span><span class="c">! complete updating f1 and f2 while col &gt; 0.</span>
<span class="w">               </span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dibp</span><span class="o">*</span><span class="n">wmc</span>
<span class="w">               </span><span class="n">f2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">two</span><span class="o">*</span><span class="n">dibp</span><span class="o">*</span><span class="n">wmp</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">dibp2</span><span class="o">*</span><span class="n">wmw</span>
<span class="w">            </span><span class="k">endif</span>

<span class="k">            </span><span class="n">f2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">max</span><span class="p">(</span><span class="n">Epsmch</span><span class="o">*</span><span class="n">f2_org</span><span class="p">,</span><span class="n">f2</span><span class="p">)</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">nleft</span><span class="o">&gt;</span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="k">               </span><span class="n">dtm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">f1</span><span class="o">/</span><span class="n">f2</span>
<span class="w">               </span><span class="c">! to repeat the loop for unsearched intervals.</span>
<span class="w">            </span><span class="k">else if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">bnded</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="k">               </span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zero</span>
<span class="w">               </span><span class="n">f2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zero</span>
<span class="w">               </span><span class="n">dtm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zero</span>
<span class="w">               </span><span class="k">exit </span><span class="n">main</span>
<span class="w">            </span><span class="k">else</span>
<span class="k">               </span><span class="n">dtm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">f1</span><span class="o">/</span><span class="n">f2</span>
<span class="w">               </span><span class="k">exit </span><span class="n">main</span>
<span class="w">            </span><span class="k">endif</span>

<span class="k">         end do </span><span class="n">main</span>
<span class="w">         </span><span class="c">!------------------- the end of the loop -------------------------------</span>

<span class="w">      </span><span class="k">end if</span>

<span class="k">      if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Iprint</span><span class="o">&gt;=</span><span class="mi">99</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="k">         write</span><span class="w"> </span><span class="p">(</span><span class="n">output_unit</span><span class="p">,</span><span class="o">*</span><span class="p">)</span>
<span class="w">         </span><span class="k">write</span><span class="w"> </span><span class="p">(</span><span class="n">output_unit</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="s1">&#39;GCP found in this segment&#39;</span>
<span class="w">         </span><span class="k">write</span><span class="w"> </span><span class="p">(</span><span class="n">output_unit</span><span class="p">,</span><span class="s1">&#39;(a,i3,a,1p,2(1x,d11.4))&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">                     </span><span class="s1">&#39;Piece    &#39;</span><span class="p">,</span><span class="w"> </span><span class="n">Nseg</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="s1">&#39; --f1, f2 at start point &#39;</span><span class="p">,</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">f2</span>
<span class="w">         </span><span class="k">write</span><span class="w"> </span><span class="p">(</span><span class="n">output_unit</span><span class="p">,</span><span class="s1">&#39;(A,1p,d11.4)&#39;</span><span class="p">)</span><span class="w"> </span><span class="s1">&#39;Distance to the stationary point =  &#39;</span><span class="p">,</span><span class="n">dtm</span>
<span class="w">      </span><span class="k">endif</span>
<span class="k">      if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">dtm</span><span class="o">&lt;=</span><span class="n">zero</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">dtm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zero</span>
<span class="w">      </span><span class="n">tsum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tsum</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dtm</span>

<span class="w">      </span><span class="c">! Move free variables (i.e., the ones w/o breakpoints) and</span>
<span class="w">      </span><span class="c">! the variables whose breakpoints haven&#39;t been reached.</span>

<span class="w">      </span><span class="k">call </span><span class="n">daxpy</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">tsum</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">Xcp</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="w">      </span><span class="k">call </span><span class="n">update</span><span class="p">()</span>

<span class="w">      </span><span class="k">contains</span>

<span class="k">      subroutine </span><span class="n">update</span><span class="p">()</span>

<span class="w">         </span><span class="c">! Update c = c + dtm*p = W&#39;(x^c - x)</span>
<span class="w">         </span><span class="c">! which will be used in computing r = Z&#39;(B(x^c - x) + g).</span>

<span class="w">         </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Col</span><span class="o">&gt;</span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">call </span><span class="n">daxpy</span><span class="p">(</span><span class="n">col2</span><span class="p">,</span><span class="n">dtm</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="w">         </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Iprint</span><span class="o">&gt;</span><span class="mi">100</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">write</span><span class="w"> </span><span class="p">(</span><span class="n">output_unit</span><span class="p">,</span><span class="s1">&#39;(A,/,(4x,1p,6(1x,d11.4)))&#39;</span><span class="p">)</span><span class="w"> </span><span class="s1">&#39;Cauchy X =  &#39;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">Xcp</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
<span class="w">         </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Iprint</span><span class="o">&gt;=</span><span class="mi">99</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">write</span><span class="w"> </span><span class="p">(</span><span class="n">output_unit</span><span class="p">,</span><span class="s1">&#39;(/,A,/)&#39;</span><span class="p">)</span><span class="w"> </span><span class="s1">&#39;---------------- exit CAUCHY----------------------&#39;</span>

<span class="w">      </span><span class="k">end subroutine </span><span class="n">update</span>

<span class="w">      </span><span class="k">end subroutine </span><span class="n">cauchy</span>
</pre></div>

    </section>
    <br>
    
    </div>
  </div>

      <hr>
    </div> <!-- /container -->
    <footer>
      <div class="container">
        <div class="row justify-content-between">
          <div class="col">
            <p>
              lbfgsb
 was developed by Jacob Williams<br>              &copy; 2025 
</p>
          </div>
          <div class="col">
            <p class="text-end">
              Documentation generated by
              <a href="https://github.com/Fortran-FOSS-Programmers/ford">FORD</a>
            </p>
          </div>
        </div>
        <br>
      </div> <!-- /container -->
    </footer>

    <!-- Bootstrap core JavaScript -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>    

    <!-- MathJax JavaScript
             ================================================== -->
             <!-- Placed at the end of the document so the pages load faster -->
        <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
          TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },
          jax: ['input/TeX','input/MathML','output/HTML-CSS'],
          extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']
          });
        </script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

          <script src="../tipuesearch/tipuesearch_content.js"></script>
          <script src="../tipuesearch/tipuesearch_set.js"></script>
          <script src="../tipuesearch/tipuesearch.js"></script>

  </body>
</html>