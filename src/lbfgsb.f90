!  L-BFGS-B is released under the "New BSD License" (aka "Modified BSD License"
!  or "3-clause license")
!  Please read attached file License.txt
!
!===========   L-BFGS-B (version 3.0.  April 25, 2011  ===================
!
!     This is a modified version of L-BFGS-B. Minor changes in the updated
!     code appear preceded by a line comment as follows
!
!     c-jlm-jn
!
!     Major changes are described in the accompanying paper:
!
!         Jorge Nocedal and Jose Luis Morales, Remark on "Algorithm 778:
!         L-BFGS-B: Fortran Subroutines for Large-Scale Bound Constrained
!         Optimization"  (2011). To appear in  ACM Transactions on
!         Mathematical Software,
!
!     The paper describes an improvement and a correction to Algorithm 778.
!     It is shown that the performance of the algorithm can be improved
!     significantly by making a relatively simple modication to the subspace
!     minimization phase. The correction concerns an error caused by the use
!     of routine dpmeps to estimate machine precision.
!
!     The total work space **wa** required by the new version is
!
!                  2*m*n + 11m*m + 5*n + 8*m
!
!     the old version required
!
!                  2*m*n + 12m*m + 4*n + 12*m
!
!
!            J. Nocedal  Department of Electrical Engineering and
!                        Computer Science.
!                        Northwestern University. Evanston, IL. USA
!
!
!           J.L Morales  Departamento de Matematicas,
!                        Instituto Tecnologico Autonomo de Mexico
!                        Mexico D.F. Mexico.
!
!                        March  2011
!
!=============================================================================
      SUBROUTINE SETULB(N,M,X,L,U,Nbd,F,G,Factr,Pgtol,Wa,Iwa,Task,      &
                      & Iprint,Csave,Lsave,Isave,Dsave)
      IMPLICIT NONE
!*--SETULB51
 
      CHARACTER*60 Task , Csave
      LOGICAL Lsave(4)
      INTEGER N , M , Iprint , Nbd(N) , Iwa(3*N) , Isave(44)
!
!-jlm-jn
      DOUBLE PRECISION F , Factr , Pgtol , X(N) , L(N) , U(N) , G(N) ,  &
                     & Wa(2*M*N+5*N+11*M*M+8*M) , Dsave(29)
 
!     ************
!
!     Subroutine setulb
!
!     This subroutine partitions the working arrays wa and iwa, and
!       then uses the limited memory BFGS method to solve the bound
!       constrained optimization problem by calling mainlb.
!       (The direct method will be used in the subspace minimization.)
!
!     n is an integer variable.
!       On entry n is the dimension of the problem.
!       On exit n is unchanged.
!
!     m is an integer variable.
!       On entry m is the maximum number of variable metric corrections
!         used to define the limited memory matrix.
!       On exit m is unchanged.
!
!     x is a double precision array of dimension n.
!       On entry x is an approximation to the solution.
!       On exit x is the current approximation.
!
!     l is a double precision array of dimension n.
!       On entry l is the lower bound on x.
!       On exit l is unchanged.
!
!     u is a double precision array of dimension n.
!       On entry u is the upper bound on x.
!       On exit u is unchanged.
!
!     nbd is an integer array of dimension n.
!       On entry nbd represents the type of bounds imposed on the
!         variables, and must be specified as follows:
!         nbd(i)=0 if x(i) is unbounded,
!                1 if x(i) has only a lower bound,
!                2 if x(i) has both lower and upper bounds, and
!                3 if x(i) has only an upper bound.
!       On exit nbd is unchanged.
!
!     f is a double precision variable.
!       On first entry f is unspecified.
!       On final exit f is the value of the function at x.
!
!     g is a double precision array of dimension n.
!       On first entry g is unspecified.
!       On final exit g is the value of the gradient at x.
!
!     factr is a double precision variable.
!       On entry factr >= 0 is specified by the user.  The iteration
!         will stop when
!
!         (f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} <= factr*epsmch
!
!         where epsmch is the machine precision, which is automatically
!         generated by the code. Typical values for factr: 1.d+12 for
!         low accuracy; 1.d+7 for moderate accuracy; 1.d+1 for extremely
!         high accuracy.
!       On exit factr is unchanged.
!
!     pgtol is a double precision variable.
!       On entry pgtol >= 0 is specified by the user.  The iteration
!         will stop when
!
!                 max{|proj g_i | i = 1, ..., n} <= pgtol
!
!         where pg_i is the ith component of the projected gradient.
!       On exit pgtol is unchanged.
!
!     wa is a double precision working array of length
!       (2mmax + 5)nmax + 12mmax^2 + 12mmax.
!
!     iwa is an integer working array of length 3nmax.
!
!     task is a working string of characters of length 60 indicating
!       the current job when entering and quitting this subroutine.
!
!     iprint is an integer variable that must be set by the user.
!       It controls the frequency and type of output generated:
!        iprint<0    no output is generated;
!        iprint=0    print only one line at the last iteration;
!        0<iprint<99 print also f and |proj g| every iprint iterations;
!        iprint=99   print details of every iteration except n-vectors;
!        iprint=100  print also the changes of active set and final x;
!        iprint>100  print details of every iteration including x and g;
!       When iprint > 0, the file iterate.dat will be created to
!                        summarize the iteration.
!
!     csave is a working string of characters of length 60.
!
!     lsave is a logical working array of dimension 4.
!       On exit with 'task' = NEW_X, the following information is
!                                                             available:
!         If lsave(1) = .true.  then  the initial X has been replaced by
!                                     its projection in the feasible set;
!         If lsave(2) = .true.  then  the problem is constrained;
!         If lsave(3) = .true.  then  each variable has upper and lower
!                                     bounds;
!
!     isave is an integer working array of dimension 44.
!       On exit with 'task' = NEW_X, the following information is
!                                                             available:
!         isave(22) = the total number of intervals explored in the
!                         search of Cauchy points;
!         isave(26) = the total number of skipped BFGS updates before
!                         the current iteration;
!         isave(30) = the number of current iteration;
!         isave(31) = the total number of BFGS updates prior the current
!                         iteration;
!         isave(33) = the number of intervals explored in the search of
!                         Cauchy point in the current iteration;
!         isave(34) = the total number of function and gradient
!                         evaluations;
!         isave(36) = the number of function value or gradient
!                                  evaluations in the current iteration;
!         if isave(37) = 0  then the subspace argmin is within the box;
!         if isave(37) = 1  then the subspace argmin is beyond the box;
!         isave(38) = the number of free variables in the current
!                         iteration;
!         isave(39) = the number of active constraints in the current
!                         iteration;
!         n + 1 - isave(40) = the number of variables leaving the set of
!                           active constraints in the current iteration;
!         isave(41) = the number of variables entering the set of active
!                         constraints in the current iteration.
!
!     dsave is a double precision working array of dimension 29.
!       On exit with 'task' = NEW_X, the following information is
!                                                             available:
!         dsave(1) = current 'theta' in the BFGS matrix;
!         dsave(2) = f(x) in the previous iteration;
!         dsave(3) = factr*epsmch;
!         dsave(4) = 2-norm of the line search direction vector;
!         dsave(5) = the machine precision epsmch generated by the code;
!         dsave(7) = the accumulated time spent on searching for
!                                                         Cauchy points;
!         dsave(8) = the accumulated time spent on
!                                                 subspace minimization;
!         dsave(9) = the accumulated time spent on line search;
!         dsave(11) = the slope of the line search function at
!                                  the current point of line search;
!         dsave(12) = the maximum relative step length imposed in
!                                                           line search;
!         dsave(13) = the infinity norm of the projected gradient;
!         dsave(14) = the relative step length in the line search;
!         dsave(15) = the slope of the line search function at
!                                 the starting point of the line search;
!         dsave(16) = the square of the 2-norm of the line search
!                                                      direction vector.
!
!     Subprograms called:
!
!       L-BFGS-B Library ... mainlb.
!
!
!     References:
!
!       [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited
!       memory algorithm for bound constrained optimization'',
!       SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208.
!
!       [2] C. Zhu, R.H. Byrd, P. Lu, J. Nocedal, ``L-BFGS-B: a
!       limited memory FORTRAN code for solving bound constrained
!       optimization problems'', Tech. Report, NAM-11, EECS Department,
!       Northwestern University, 1994.
!
!       (Postscript files of these papers are available via anonymous
!        ftp to eecs.nwu.edu in the directory pub/lbfgs/lbfgs_bcm.)
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     ************
!-jlm-jn
      INTEGER lws , lr , lz , lt , ld , lxp , lwa , lwy , lsy , lss ,   &
            & lwt , lwn , lsnd
 
      IF ( Task.EQ.'START' ) THEN
         Isave(1) = M*N
         Isave(2) = M**2
         Isave(3) = 4*M**2
         Isave(4) = 1                       ! ws      m*n
         Isave(5) = Isave(4) + Isave(1)     ! wy      m*n
         Isave(6) = Isave(5) + Isave(1)     ! wsy     m**2
         Isave(7) = Isave(6) + Isave(2)     ! wss     m**2
         Isave(8) = Isave(7) + Isave(2)     ! wt      m**2
         Isave(9) = Isave(8) + Isave(2)     ! wn      4*m**2
         Isave(10) = Isave(9) + Isave(3)    ! wsnd    4*m**2
         Isave(11) = Isave(10) + Isave(3)   ! wz      n
         Isave(12) = Isave(11) + N          ! wr      n
         Isave(13) = Isave(12) + N          ! wd      n
         Isave(14) = Isave(13) + N          ! wt      n
         Isave(15) = Isave(14) + N          ! wxp     n
         Isave(16) = Isave(15) + N          ! wa      8*m
      ENDIF
      lws = Isave(4)
      lwy = Isave(5)
      lsy = Isave(6)
      lss = Isave(7)
      lwt = Isave(8)
      lwn = Isave(9)
      lsnd = Isave(10)
      lz = Isave(11)
      lr = Isave(12)
      ld = Isave(13)
      lt = Isave(14)
      lxp = Isave(15)
      lwa = Isave(16)
 
      CALL MAINLB(N,M,X,L,U,Nbd,F,G,Factr,Pgtol,Wa(lws),Wa(lwy),Wa(lsy),&
                & Wa(lss),Wa(lwt),Wa(lwn),Wa(lsnd),Wa(lz),Wa(lr),Wa(ld),&
                & Wa(lt),Wa(lxp),Wa(lwa),Iwa(1),Iwa(N+1),Iwa(2*N+1),    &
                & Task,Iprint,Csave,Lsave,Isave(22),Dsave)
 
      CONTINUE
 
      END
 
!======================= The end of setulb =============================
 
      SUBROUTINE MAINLB(N,M,X,L,U,Nbd,F,G,Factr,Pgtol,Ws,Wy,Sy,Ss,Wt,Wn,&
                      & Snd,Z,R,D,T,Xp,Wa,Index,Iwhere,Indx2,Task,      &
                      & Iprint,Csave,Lsave,Isave,Dsave)
      IMPLICIT NONE
!*--MAINLB292
      CHARACTER*60 Task , Csave
      LOGICAL Lsave(4)
      INTEGER N , M , Iprint , Nbd(N) , Index(N) , Iwhere(N) , Indx2(N) &
            & , Isave(23)
!-jlm-jn
      DOUBLE PRECISION F , Factr , Pgtol , X(N) , L(N) , U(N) , G(N) ,  &
                     & Z(N) , R(N) , D(N) , T(N) , Xp(N) , Wa(8*M) ,    &
                     & Ws(N,M) , Wy(N,M) , Sy(M,M) , Ss(M,M) , Wt(M,M) ,&
                     & Wn(2*M,2*M) , Snd(2*M,2*M) , Dsave(29)
 
!     ************
!
!     Subroutine mainlb
!
!     This subroutine solves bound constrained optimization problems by
!       using the compact formula of the limited memory BFGS updates.
!
!     n is an integer variable.
!       On entry n is the number of variables.
!       On exit n is unchanged.
!
!     m is an integer variable.
!       On entry m is the maximum number of variable metric
!          corrections allowed in the limited memory matrix.
!       On exit m is unchanged.
!
!     x is a double precision array of dimension n.
!       On entry x is an approximation to the solution.
!       On exit x is the current approximation.
!
!     l is a double precision array of dimension n.
!       On entry l is the lower bound of x.
!       On exit l is unchanged.
!
!     u is a double precision array of dimension n.
!       On entry u is the upper bound of x.
!       On exit u is unchanged.
!
!     nbd is an integer array of dimension n.
!       On entry nbd represents the type of bounds imposed on the
!         variables, and must be specified as follows:
!         nbd(i)=0 if x(i) is unbounded,
!                1 if x(i) has only a lower bound,
!                2 if x(i) has both lower and upper bounds,
!                3 if x(i) has only an upper bound.
!       On exit nbd is unchanged.
!
!     f is a double precision variable.
!       On first entry f is unspecified.
!       On final exit f is the value of the function at x.
!
!     g is a double precision array of dimension n.
!       On first entry g is unspecified.
!       On final exit g is the value of the gradient at x.
!
!     factr is a double precision variable.
!       On entry factr >= 0 is specified by the user.  The iteration
!         will stop when
!
!         (f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} <= factr*epsmch
!
!         where epsmch is the machine precision, which is automatically
!         generated by the code.
!       On exit factr is unchanged.
!
!     pgtol is a double precision variable.
!       On entry pgtol >= 0 is specified by the user.  The iteration
!         will stop when
!
!                 max{|proj g_i | i = 1, ..., n} <= pgtol
!
!         where pg_i is the ith component of the projected gradient.
!       On exit pgtol is unchanged.
!
!     ws, wy, sy, and wt are double precision working arrays used to
!       store the following information defining the limited memory
!          BFGS matrix:
!          ws, of dimension n x m, stores S, the matrix of s-vectors;
!          wy, of dimension n x m, stores Y, the matrix of y-vectors;
!          sy, of dimension m x m, stores S'Y;
!          ss, of dimension m x m, stores S'S;
!          yy, of dimension m x m, stores Y'Y;
!          wt, of dimension m x m, stores the Cholesky factorization
!                                  of (theta*S'S+LD^(-1)L'); see eq.
!                                  (2.26) in [3].
!
!     wn is a double precision working array of dimension 2m x 2m
!       used to store the LEL^T factorization of the indefinite matrix
!                 K = [-D -Y'ZZ'Y/theta     L_a'-R_z'  ]
!                     [L_a -R_z           theta*S'AA'S ]
!
!       where     E = [-I  0]
!                     [ 0  I]
!
!     snd is a double precision working array of dimension 2m x 2m
!       used to store the lower triangular part of
!                 N = [Y' ZZ'Y   L_a'+R_z']
!                     [L_a +R_z  S'AA'S   ]
!
!     z(n),r(n),d(n),t(n), xp(n),wa(8*m) are double precision working arrays.
!       z  is used at different times to store the Cauchy point and
!          the Newton point.
!       xp is used to safeguard the projected Newton direction
!
!     sg(m),sgo(m),yg(m),ygo(m) are double precision working arrays.
!
!     index is an integer working array of dimension n.
!       In subroutine freev, index is used to store the free and fixed
!          variables at the Generalized Cauchy Point (GCP).
!
!     iwhere is an integer working array of dimension n used to record
!       the status of the vector x for GCP computation.
!       iwhere(i)=0 or -3 if x(i) is free and has bounds,
!                 1       if x(i) is fixed at l(i), and l(i) .ne. u(i)
!                 2       if x(i) is fixed at u(i), and u(i) .ne. l(i)
!                 3       if x(i) is always fixed, i.e.,  u(i)=x(i)=l(i)
!                -1       if x(i) is always free, i.e., no bounds on it.
!
!     indx2 is an integer working array of dimension n.
!       Within subroutine cauchy, indx2 corresponds to the array iorder.
!       In subroutine freev, a list of variables entering and leaving
!       the free set is stored in indx2, and it is passed on to
!       subroutine formk with this information.
!
!     task is a working string of characters of length 60 indicating
!       the current job when entering and leaving this subroutine.
!
!     iprint is an INTEGER variable that must be set by the user.
!       It controls the frequency and type of output generated:
!        iprint<0    no output is generated;
!        iprint=0    print only one line at the last iteration;
!        0<iprint<99 print also f and |proj g| every iprint iterations;
!        iprint=99   print details of every iteration except n-vectors;
!        iprint=100  print also the changes of active set and final x;
!        iprint>100  print details of every iteration including x and g;
!       When iprint > 0, the file iterate.dat will be created to
!                        summarize the iteration.
!
!     csave is a working string of characters of length 60.
!
!     lsave is a logical working array of dimension 4.
!
!     isave is an integer working array of dimension 23.
!
!     dsave is a double precision working array of dimension 29.
!
!
!     Subprograms called
!
!       L-BFGS-B Library ... cauchy, subsm, lnsrlb, formk,
!
!        errclb, prn1lb, prn2lb, prn3lb, active, projgr,
!
!        freev, cmprlb, matupd, formt.
!
!       Minpack2 Library ... timer
!
!       Linpack Library ... dcopy, ddot.
!
!
!     References:
!
!       [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited
!       memory algorithm for bound constrained optimization'',
!       SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208.
!
!       [2] C. Zhu, R.H. Byrd, P. Lu, J. Nocedal, ``L-BFGS-B: FORTRAN
!       Subroutines for Large Scale Bound Constrained Optimization''
!       Tech. Report, NAM-11, EECS Department, Northwestern University,
!       1994.
!
!       [3] R. Byrd, J. Nocedal and R. Schnabel "Representations of
!       Quasi-Newton Matrices and their use in Limited Memory Methods'',
!       Mathematical Programming 63 (1994), no. 4, pp. 129-156.
!
!       (Postscript files of these papers are available via anonymous
!        ftp to eecs.nwu.edu in the directory pub/lbfgs/lbfgs_bcm.)
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     ************
 
      LOGICAL prjctd , cnstnd , boxed , updatd , wrk
      CHARACTER*3 word
      INTEGER i , k , nintol , itfile , iback , nskip , head , col ,    &
            & iter , itail , iupdat , nseg , nfgv , info , ifun ,       &
            & iword , nfree , nact , ileave , nenter
      DOUBLE PRECISION theta , fold , DDOT , dr , rr , tol , xstep ,    &
                     & sbgnrm , ddum , dnorm , dtd , epsmch , cpu1 ,    &
                     & cpu2 , cachyt , sbtime , lnscht , time1 , time2 ,&
                     & gd , gdold , stp , stpmx , time
      DOUBLE PRECISION ONE , ZERO
      PARAMETER (ONE=1.0D0,ZERO=0.0D0)
 
      IF ( Task.EQ.'START' ) THEN
 
         epsmch = EPSILON(ONE)
 
         CALL TIMER(time1)
 
!        Initialize counters and scalars when task='START'.
 
!           for the limited memory BFGS matrices:
         col = 0
         head = 1
         theta = ONE
         iupdat = 0
         updatd = .FALSE.
         iback = 0
         itail = 0
         iword = 0
         nact = 0
         ileave = 0
         nenter = 0
         fold = ZERO
         dnorm = ZERO
         cpu1 = ZERO
         gd = ZERO
         stpmx = ZERO
         sbgnrm = ZERO
         stp = ZERO
         gdold = ZERO
         dtd = ZERO
 
!           for operation counts:
         iter = 0
         nfgv = 0
         nseg = 0
         nintol = 0
         nskip = 0
         nfree = N
         ifun = 0
!           for stopping tolerance:
         tol = Factr*epsmch
 
!           for measuring running time:
         cachyt = 0
         sbtime = 0
         lnscht = 0
 
!           'word' records the status of subspace solutions.
         word = '---'
 
!           'info' records the termination information.
         info = 0
 
         itfile = 8
!                                open a summary file 'iterate.dat'
         IF ( Iprint.GE.1 ) OPEN (8,FILE='iterate.dat',STATUS='unknown')
 
!        Check the input arguments for errors.
 
         CALL ERRCLB(N,M,Factr,L,U,Nbd,Task,info,k)
         IF ( Task(1:5).EQ.'ERROR' ) THEN
            CALL PRN3LB(N,X,F,Task,Iprint,info,itfile,iter,nfgv,nintol, &
                      & nskip,nact,sbgnrm,ZERO,nseg,word,iback,stp,     &
                      & xstep,k,cachyt,sbtime,lnscht)
            RETURN
         ENDIF
 
         CALL PRN1LB(N,M,L,U,X,Iprint,itfile,epsmch)
 
!        Initialize iwhere & project x onto the feasible set.
 
         CALL ACTIVE(N,L,U,Nbd,X,Iwhere,Iprint,prjctd,cnstnd,boxed)
 
!        The end of the initialization.
 
      ELSE
!          restore local variables.
 
         prjctd = Lsave(1)
         cnstnd = Lsave(2)
         boxed = Lsave(3)
         updatd = Lsave(4)
 
         nintol = Isave(1)
         itfile = Isave(3)
         iback = Isave(4)
         nskip = Isave(5)
         head = Isave(6)
         col = Isave(7)
         itail = Isave(8)
         iter = Isave(9)
         iupdat = Isave(10)
         nseg = Isave(12)
         nfgv = Isave(13)
         info = Isave(14)
         ifun = Isave(15)
         iword = Isave(16)
         nfree = Isave(17)
         nact = Isave(18)
         ileave = Isave(19)
         nenter = Isave(20)
 
         theta = Dsave(1)
         fold = Dsave(2)
         tol = Dsave(3)
         dnorm = Dsave(4)
         epsmch = Dsave(5)
         cpu1 = Dsave(6)
         cachyt = Dsave(7)
         sbtime = Dsave(8)
         lnscht = Dsave(9)
         time1 = Dsave(10)
         gd = Dsave(11)
         stpmx = Dsave(12)
         sbgnrm = Dsave(13)
         stp = Dsave(14)
         gdold = Dsave(15)
         dtd = Dsave(16)
 
!        After returning from the driver go to the point where execution
!        is to resume.
 
         IF ( Task(1:5).EQ.'FG_LN' ) GOTO 600
         IF ( Task(1:5).EQ.'NEW_X' ) GOTO 700
         IF ( Task(1:5).EQ.'FG_ST' ) GOTO 100
         IF ( Task(1:4).EQ.'STOP' ) THEN
            IF ( Task(7:9).EQ.'CPU' ) THEN
!                                          restore the previous iterate.
               CALL DCOPY(N,T,1,X,1)
               CALL DCOPY(N,R,1,G,1)
               F = fold
            ENDIF
            GOTO 900
         ENDIF
      ENDIF
 
!     Compute f0 and g0.
 
      Task = 'FG_START'
!          return to the driver to calculate f and g; reenter at 111.
      GOTO 1000
 100  CONTINUE
      nfgv = 1
 
!     Compute the infinity norm of the (-) projected gradient.
 
      CALL PROJGR(N,L,U,Nbd,X,G,sbgnrm)
 
      IF ( Iprint.GE.1 ) THEN
         WRITE (6,99001) iter , F , sbgnrm
99001    FORMAT (/,'At iterate',i5,4x,'f= ',1p,d12.5,4x,'|proj g|= ',1p,&
               & d12.5)
         WRITE (itfile,99002) iter , nfgv , sbgnrm , F
99002    FORMAT (2(1x,i4),5x,'-',5x,'-',3x,'-',5x,'-',5x,'-',8x,'-',3x, &
               & 1p,2(1x,d10.3))
      ENDIF
      IF ( sbgnrm.LE.Pgtol ) THEN
!                                terminate the algorithm.
         Task = 'CONVERGENCE: NORM_OF_PROJECTED_GRADIENT_<=_PGTOL'
         GOTO 900
      ENDIF
 
! ----------------- the beginning of the loop --------------------------
 
 200  CONTINUE
      IF ( Iprint.GE.99 ) WRITE (6,99003) iter + 1
 
99003 FORMAT (//,'ITERATION ',i5)
      iword = -1
!
      IF ( .NOT.cnstnd .AND. col.GT.0 ) THEN
!                                            skip the search for GCP.
         CALL DCOPY(N,X,1,Z,1)
         wrk = updatd
         nseg = 0
         GOTO 300
      ENDIF
 
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!     Compute the Generalized Cauchy Point (GCP).
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
      CALL TIMER(cpu1)
      CALL CAUCHY(N,X,L,U,Nbd,G,Indx2,Iwhere,T,D,Z,M,Wy,Ws,Sy,Wt,theta, &
                & col,head,Wa(1),Wa(2*M+1),Wa(4*M+1),Wa(6*M+1),nseg,    &
                & Iprint,sbgnrm,info,epsmch)
      IF ( info.NE.0 ) THEN
!         singular triangular system detected; refresh the lbfgs memory.
         IF ( Iprint.GE.1 ) WRITE (6,99008)
         info = 0
         col = 0
         head = 1
         theta = ONE
         iupdat = 0
         updatd = .FALSE.
         CALL TIMER(cpu2)
         cachyt = cachyt + cpu2 - cpu1
         GOTO 200
      ENDIF
      CALL TIMER(cpu2)
      cachyt = cachyt + cpu2 - cpu1
      nintol = nintol + nseg
 
!     Count the entering and leaving variables for iter > 0;
!     find the index set of free and active variables at the GCP.
 
      CALL FREEV(N,nfree,Index,nenter,ileave,Indx2,Iwhere,wrk,updatd,   &
               & cnstnd,Iprint,iter)
      nact = N - nfree
 
 300  CONTINUE
 
!     If there are no free variables or B=theta*I, then
!                                        skip the subspace minimization.
 
      IF ( nfree.EQ.0 .OR. col.EQ.0 ) GOTO 500
 
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!     Subspace minimization.
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
      CALL TIMER(cpu1)
 
!     Form  the LEL^T factorization of the indefinite
!       matrix    K = [-D -Y'ZZ'Y/theta     L_a'-R_z'  ]
!                     [L_a -R_z           theta*S'AA'S ]
!       where     E = [-I  0]
!                     [ 0  I]
 
      IF ( wrk ) CALL FORMK(N,nfree,Index,nenter,ileave,Indx2,iupdat,   &
                          & updatd,Wn,Snd,M,Ws,Wy,Sy,theta,col,head,    &
                          & info)
      IF ( info.NE.0 ) THEN
!          nonpositive definiteness in Cholesky factorization;
!          refresh the lbfgs memory and restart the iteration.
         IF ( Iprint.GE.1 ) WRITE (6,99004)
99004    FORMAT (/,                                                     &
        &' Nonpositive definiteness in Cholesky factorization in formk;'&
       & ,/,'   refresh the lbfgs memory and restart the iteration.')
         info = 0
         col = 0
         head = 1
         theta = ONE
         iupdat = 0
         updatd = .FALSE.
         CALL TIMER(cpu2)
         sbtime = sbtime + cpu2 - cpu1
         GOTO 200
      ENDIF
 
!        compute r=-Z'B(xcp-xk)-Z'g (using wa(2m+1)=W'(xcp-x)
!                                                   from 'cauchy').
      CALL CMPRLB(N,M,X,G,Ws,Wy,Sy,Wt,Z,R,Wa,Index,theta,col,head,nfree,&
                & cnstnd,info)
      IF ( info.NE.0 ) GOTO 400
 
!-jlm-jn   call the direct method.
 
      CALL SUBSM(N,M,nfree,Index,L,U,Nbd,Z,R,Xp,Ws,Wy,theta,X,G,col,    &
               & head,iword,Wa,Wn,Iprint,info)
 400  CONTINUE
      IF ( info.NE.0 ) THEN
!          singular triangular system detected;
!          refresh the lbfgs memory and restart the iteration.
         IF ( Iprint.GE.1 ) WRITE (6,99008)
         info = 0
         col = 0
         head = 1
         theta = ONE
         iupdat = 0
         updatd = .FALSE.
         CALL TIMER(cpu2)
         sbtime = sbtime + cpu2 - cpu1
         GOTO 200
      ENDIF
 
      CALL TIMER(cpu2)
      sbtime = sbtime + cpu2 - cpu1
 500  CONTINUE
 
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!     Line search and optimality tests.
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
!     Generate the search direction d:=z-x.
 
      DO i = 1 , N
         D(i) = Z(i) - X(i)
      ENDDO
      CALL TIMER(cpu1)
 600  CONTINUE
      CALL LNSRLB(N,L,U,Nbd,X,F,fold,gd,gdold,G,D,R,T,Z,stp,dnorm,dtd,  &
                & xstep,stpmx,iter,ifun,iback,nfgv,info,Task,boxed,     &
                & cnstnd,Csave,Isave(22),Dsave(17))
      IF ( info.NE.0 .OR. iback.GE.20 ) THEN
!          restore the previous iterate.
         CALL DCOPY(N,T,1,X,1)
         CALL DCOPY(N,R,1,G,1)
         F = fold
         IF ( col.EQ.0 ) THEN
!             abnormal termination.
            IF ( info.EQ.0 ) THEN
               info = -9
!                restore the actual number of f and g evaluations etc.
               nfgv = nfgv - 1
               ifun = ifun - 1
               iback = iback - 1
            ENDIF
            Task = 'ABNORMAL_TERMINATION_IN_LNSRCH'
            iter = iter + 1
            GOTO 900
         ELSE
!             refresh the lbfgs memory and restart the iteration.
            IF ( Iprint.GE.1 ) WRITE (6,99005)
99005       FORMAT (/,' Bad direction in the line search;',/,           &
               &'   refresh the lbfgs memory and restart the iteration.'&
              & )
            IF ( info.EQ.0 ) nfgv = nfgv - 1
            info = 0
            col = 0
            head = 1
            theta = ONE
            iupdat = 0
            updatd = .FALSE.
            Task = 'RESTART_FROM_LNSRCH'
            CALL TIMER(cpu2)
            lnscht = lnscht + cpu2 - cpu1
            GOTO 200
         ENDIF
      ELSEIF ( Task(1:5).EQ.'FG_LN' ) THEN
!          return to the driver for calculating f and g; reenter at 666.
         GOTO 1000
      ELSE
!          calculate and print out the quantities related to the new X.
         CALL TIMER(cpu2)
         lnscht = lnscht + cpu2 - cpu1
         iter = iter + 1
 
!        Compute the infinity norm of the projected (-)gradient.
 
         CALL PROJGR(N,L,U,Nbd,X,G,sbgnrm)
 
!        Print iteration information.
 
         CALL PRN2LB(N,X,F,G,Iprint,itfile,iter,nfgv,nact,sbgnrm,nseg,  &
                   & word,iword,iback,stp,xstep)
         GOTO 1000
      ENDIF
 700  CONTINUE
 
!     Test for termination.
 
      IF ( sbgnrm.LE.Pgtol ) THEN
!                                terminate the algorithm.
         Task = 'CONVERGENCE: NORM_OF_PROJECTED_GRADIENT_<=_PGTOL'
         GOTO 900
      ENDIF
 
      ddum = MAX(ABS(fold),ABS(F),ONE)
      IF ( (fold-F).LE.tol*ddum ) THEN
!                                        terminate the algorithm.
         Task = 'CONVERGENCE: REL_REDUCTION_OF_F_<=_FACTR*EPSMCH'
         IF ( iback.GE.10 ) info = -5
!           i.e., to issue a warning if iback>10 in the line search.
         GOTO 900
      ENDIF
 
!     Compute d=newx-oldx, r=newg-oldg, rr=y'y and dr=y's.
 
      DO i = 1 , N
         R(i) = G(i) - R(i)
      ENDDO
      rr = DDOT(N,R,1,R,1)
      IF ( stp.EQ.ONE ) THEN
         dr = gd - gdold
         ddum = -gdold
      ELSE
         dr = (gd-gdold)*stp
         CALL DSCAL(N,stp,D,1)
         ddum = -gdold*stp
      ENDIF
 
      IF ( dr.LE.epsmch*ddum ) THEN
!                            skip the L-BFGS update.
         nskip = nskip + 1
         updatd = .FALSE.
         IF ( Iprint.GE.1 ) WRITE (6,99006) dr , ddum
99006    FORMAT ('  ys=',1p,e10.3,'  -gs=',1p,e10.3,                    &
                &' BFGS update SKIPPED')
         GOTO 800
      ENDIF
 
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!     Update the L-BFGS matrix.
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
      updatd = .TRUE.
      iupdat = iupdat + 1
 
!     Update matrices WS and WY and form the middle matrix in B.
 
      CALL MATUPD(N,M,Ws,Wy,Sy,Ss,D,R,itail,iupdat,col,head,theta,rr,dr,&
                & stp,dtd)
 
!     Form the upper half of the pds T = theta*SS + L*D^(-1)*L';
!        Store T in the upper triangular of the array wt;
!        Cholesky factorize T to J*J' with
!           J' stored in the upper triangular of wt.
 
      CALL FORMT(M,Wt,Sy,Ss,col,theta,info)
 
      IF ( info.NE.0 ) THEN
!          nonpositive definiteness in Cholesky factorization;
!          refresh the lbfgs memory and restart the iteration.
         IF ( Iprint.GE.1 ) WRITE (6,99007)
99007    FORMAT (/,                                                     &
        &' Nonpositive definiteness in Cholesky factorization in formt;'&
       & ,/,'   refresh the lbfgs memory and restart the iteration.')
         info = 0
         col = 0
         head = 1
         theta = ONE
         iupdat = 0
         updatd = .FALSE.
         GOTO 200
      ENDIF
 
!     Now the inverse of the middle matrix in B is
 
!       [  D^(1/2)      O ] [ -D^(1/2)  D^(-1/2)*L' ]
!       [ -L*D^(-1/2)   J ] [  0        J'          ]
 
 800  CONTINUE
 
! -------------------- the end of the loop -----------------------------
 
      GOTO 200
 900  CONTINUE
      CALL TIMER(time2)
      time = time2 - time1
      CALL PRN3LB(N,X,F,Task,Iprint,info,itfile,iter,nfgv,nintol,nskip, &
                & nact,sbgnrm,time,nseg,word,iback,stp,xstep,k,cachyt,  &
                & sbtime,lnscht)
 1000 CONTINUE
 
!     Save local variables.
 
      Lsave(1) = prjctd
      Lsave(2) = cnstnd
      Lsave(3) = boxed
      Lsave(4) = updatd
 
      Isave(1) = nintol
      Isave(3) = itfile
      Isave(4) = iback
      Isave(5) = nskip
      Isave(6) = head
      Isave(7) = col
      Isave(8) = itail
      Isave(9) = iter
      Isave(10) = iupdat
      Isave(12) = nseg
      Isave(13) = nfgv
      Isave(14) = info
      Isave(15) = ifun
      Isave(16) = iword
      Isave(17) = nfree
      Isave(18) = nact
      Isave(19) = ileave
      Isave(20) = nenter
 
      Dsave(1) = theta
      Dsave(2) = fold
      Dsave(3) = tol
      Dsave(4) = dnorm
      Dsave(5) = epsmch
      Dsave(6) = cpu1
      Dsave(7) = cachyt
      Dsave(8) = sbtime
      Dsave(9) = lnscht
      Dsave(10) = time1
      Dsave(11) = gd
      Dsave(12) = stpmx
      Dsave(13) = sbgnrm
      Dsave(14) = stp
      Dsave(15) = gdold
      Dsave(16) = dtd
 
      CONTINUE
99008 FORMAT (/,' Singular triangular system detected;',/,              &
             &'   refresh the lbfgs memory and restart the iteration.')
 
      END
 
!======================= The end of mainlb =============================
 
      SUBROUTINE ACTIVE(N,L,U,Nbd,X,Iwhere,Iprint,Prjctd,Cnstnd,Boxed)
      IMPLICIT NONE
!*--ACTIVE1001
 
      LOGICAL Prjctd , Cnstnd , Boxed
      INTEGER N , Iprint , Nbd(N) , Iwhere(N)
      DOUBLE PRECISION X(N) , L(N) , U(N)
 
!     ************
!
!     Subroutine active
!
!     This subroutine initializes iwhere and projects the initial x to
!       the feasible set if necessary.
!
!     iwhere is an integer array of dimension n.
!       On entry iwhere is unspecified.
!       On exit iwhere(i)=-1  if x(i) has no bounds
!                         3   if l(i)=u(i)
!                         0   otherwise.
!       In cauchy, iwhere is given finer gradations.
!
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     ************
 
      INTEGER nbdd , i
      DOUBLE PRECISION ZERO
      PARAMETER (ZERO=0.0D0)
 
!     Initialize nbdd, prjctd, cnstnd and boxed.
 
      nbdd = 0
      Prjctd = .FALSE.
      Cnstnd = .FALSE.
      Boxed = .TRUE.
 
!     Project the initial x to the easible set if necessary.
 
      DO i = 1 , N
         IF ( Nbd(i).GT.0 ) THEN
            IF ( Nbd(i).LE.2 .AND. X(i).LE.L(i) ) THEN
               IF ( X(i).LT.L(i) ) THEN
                  Prjctd = .TRUE.
                  X(i) = L(i)
               ENDIF
               nbdd = nbdd + 1
            ELSEIF ( Nbd(i).GE.2 .AND. X(i).GE.U(i) ) THEN
               IF ( X(i).GT.U(i) ) THEN
                  Prjctd = .TRUE.
                  X(i) = U(i)
               ENDIF
               nbdd = nbdd + 1
            ENDIF
         ENDIF
      ENDDO
 
!     Initialize iwhere and assign values to cnstnd and boxed.
 
      DO i = 1 , N
         IF ( Nbd(i).NE.2 ) Boxed = .FALSE.
         IF ( Nbd(i).EQ.0 ) THEN
!                                this variable is always free
            Iwhere(i) = -1
 
!           otherwise set x(i)=mid(x(i), u(i), l(i)).
         ELSE
            Cnstnd = .TRUE.
            IF ( Nbd(i).EQ.2 .AND. U(i)-L(i).LE.ZERO ) THEN
!                   this variable is always fixed
               Iwhere(i) = 3
            ELSE
               Iwhere(i) = 0
            ENDIF
         ENDIF
      ENDDO
 
      IF ( Iprint.GE.0 ) THEN
         IF ( Prjctd ) WRITE (6,*)                                      &
           &'The initial X is infeasible.  Restart with its projection.'
         IF ( .NOT.Cnstnd ) WRITE (6,*) 'This problem is unconstrained.'
      ENDIF
 
      IF ( Iprint.GT.0 ) WRITE (6,99001) nbdd
 
99001 FORMAT (/,'At X0 ',i9,' variables are exactly at the bounds')
 
      CONTINUE
 
      END
 
!======================= The end of active =============================
 
      SUBROUTINE BMV(M,Sy,Wt,Col,V,P,Info)
      IMPLICIT NONE
!*--BMV1104
 
      INTEGER M , Col , Info
      DOUBLE PRECISION Sy(M,M) , Wt(M,M) , V(2*Col) , P(2*Col)
 
!     ************
!
!     Subroutine bmv
!
!     This subroutine computes the product of the 2m x 2m middle matrix
!       in the compact L-BFGS formula of B and a 2m vector v;
!       it returns the product in p.
!
!     m is an integer variable.
!       On entry m is the maximum number of variable metric corrections
!         used to define the limited memory matrix.
!       On exit m is unchanged.
!
!     sy is a double precision array of dimension m x m.
!       On entry sy specifies the matrix S'Y.
!       On exit sy is unchanged.
!
!     wt is a double precision array of dimension m x m.
!       On entry wt specifies the upper triangular matrix J' which is
!         the Cholesky factor of (thetaS'S+LD^(-1)L').
!       On exit wt is unchanged.
!
!     col is an integer variable.
!       On entry col specifies the number of s-vectors (or y-vectors)
!         stored in the compact L-BFGS formula.
!       On exit col is unchanged.
!
!     v is a double precision array of dimension 2col.
!       On entry v specifies vector v.
!       On exit v is unchanged.
!
!     p is a double precision array of dimension 2col.
!       On entry p is unspecified.
!       On exit p is the product Mv.
!
!     info is an integer variable.
!       On entry info is unspecified.
!       On exit info = 0       for normal return,
!                    = nonzero for abnormal return when the system
!                                to be solved by dtrsl is singular.
!
!     Subprograms called:
!
!       Linpack ... dtrsl.
!
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     ************
 
      INTEGER i , k , i2
      DOUBLE PRECISION sum
 
      IF ( Col.EQ.0 ) RETURN
 
!     PART I: solve [  D^(1/2)      O ] [ p1 ] = [ v1 ]
!                   [ -L*D^(-1/2)   J ] [ p2 ]   [ v2 ].
 
!       solve Jp2=v2+LD^(-1)v1.
      P(Col+1) = V(Col+1)
      DO i = 2 , Col
         i2 = Col + i
         sum = 0.0D0
         DO k = 1 , i - 1
            sum = sum + Sy(i,k)*V(k)/Sy(k,k)
         ENDDO
         P(i2) = V(i2) + sum
      ENDDO
!     Solve the triangular system
      CALL DTRSL(Wt,M,Col,P(Col+1),11,Info)
      IF ( Info.NE.0 ) RETURN
 
!       solve D^(1/2)p1=v1.
      DO i = 1 , Col
         P(i) = V(i)/SQRT(Sy(i,i))
      ENDDO
 
!     PART II: solve [ -D^(1/2)   D^(-1/2)*L'  ] [ p1 ] = [ p1 ]
!                    [  0         J'           ] [ p2 ]   [ p2 ].
 
!       solve J^Tp2=p2.
      CALL DTRSL(Wt,M,Col,P(Col+1),01,Info)
      IF ( Info.NE.0 ) RETURN
 
!       compute p1=-D^(-1/2)(p1-D^(-1/2)L'p2)
!                 =-D^(-1/2)p1+D^(-1)L'p2.
      DO i = 1 , Col
         P(i) = -P(i)/SQRT(Sy(i,i))
      ENDDO
      DO i = 1 , Col
         sum = 0.D0
         DO k = i + 1 , Col
            sum = sum + Sy(k,i)*P(Col+k)/Sy(i,i)
         ENDDO
         P(i) = P(i) + sum
      ENDDO
 
      CONTINUE
 
      END
 
!======================== The end of bmv ===============================
 
      SUBROUTINE CAUCHY(N,X,L,U,Nbd,G,Iorder,Iwhere,T,D,Xcp,M,Wy,Ws,Sy, &
                      & Wt,Theta,Col,Head,P,C,Wbp,V,Nseg,Iprint,Sbgnrm, &
                      & Info,Epsmch)
      IMPLICIT NONE
!*--CAUCHY1225
      INTEGER N , M , Head , Col , Nseg , Iprint , Info , Nbd(N) ,      &
            & Iorder(N) , Iwhere(N)
      DOUBLE PRECISION Theta , Epsmch , X(N) , L(N) , U(N) , G(N) ,     &
                     & T(N) , D(N) , Xcp(N) , Wy(N,Col) , Ws(N,Col) ,   &
                     & Sy(M,M) , Wt(M,M) , P(2*M) , C(2*M) , Wbp(2*M) , &
                     & V(2*M)
 
!     ************
!
!     Subroutine cauchy
!
!     For given x, l, u, g (with sbgnrm > 0), and a limited memory
!       BFGS matrix B defined in terms of matrices WY, WS, WT, and
!       scalars head, col, and theta, this subroutine computes the
!       generalized Cauchy point (GCP), defined as the first local
!       minimizer of the quadratic
!
!                  Q(x + s) = g's + 1/2 s'Bs
!
!       along the projected gradient direction P(x-tg,l,u).
!       The routine returns the GCP in xcp.
!
!     n is an integer variable.
!       On entry n is the dimension of the problem.
!       On exit n is unchanged.
!
!     x is a double precision array of dimension n.
!       On entry x is the starting point for the GCP computation.
!       On exit x is unchanged.
!
!     l is a double precision array of dimension n.
!       On entry l is the lower bound of x.
!       On exit l is unchanged.
!
!     u is a double precision array of dimension n.
!       On entry u is the upper bound of x.
!       On exit u is unchanged.
!
!     nbd is an integer array of dimension n.
!       On entry nbd represents the type of bounds imposed on the
!         variables, and must be specified as follows:
!         nbd(i)=0 if x(i) is unbounded,
!                1 if x(i) has only a lower bound,
!                2 if x(i) has both lower and upper bounds, and
!                3 if x(i) has only an upper bound.
!       On exit nbd is unchanged.
!
!     g is a double precision array of dimension n.
!       On entry g is the gradient of f(x).  g must be a nonzero vector.
!       On exit g is unchanged.
!
!     iorder is an integer working array of dimension n.
!       iorder will be used to store the breakpoints in the piecewise
!       linear path and free variables encountered. On exit,
!         iorder(1),...,iorder(nleft) are indices of breakpoints
!                                which have not been encountered;
!         iorder(nleft+1),...,iorder(nbreak) are indices of
!                                     encountered breakpoints; and
!         iorder(nfree),...,iorder(n) are indices of variables which
!                 have no bound constraits along the search direction.
!
!     iwhere is an integer array of dimension n.
!       On entry iwhere indicates only the permanently fixed (iwhere=3)
!       or free (iwhere= -1) components of x.
!       On exit iwhere records the status of the current x variables.
!       iwhere(i)=-3  if x(i) is free and has bounds, but is not moved
!                 0   if x(i) is free and has bounds, and is moved
!                 1   if x(i) is fixed at l(i), and l(i) .ne. u(i)
!                 2   if x(i) is fixed at u(i), and u(i) .ne. l(i)
!                 3   if x(i) is always fixed, i.e.,  u(i)=x(i)=l(i)
!                 -1  if x(i) is always free, i.e., it has no bounds.
!
!     t is a double precision working array of dimension n.
!       t will be used to store the break points.
!
!     d is a double precision array of dimension n used to store
!       the Cauchy direction P(x-tg)-x.
!
!     xcp is a double precision array of dimension n used to return the
!       GCP on exit.
!
!     m is an integer variable.
!       On entry m is the maximum number of variable metric corrections
!         used to define the limited memory matrix.
!       On exit m is unchanged.
!
!     ws, wy, sy, and wt are double precision arrays.
!       On entry they store information that defines the
!                             limited memory BFGS matrix:
!         ws(n,m) stores S, a set of s-vectors;
!         wy(n,m) stores Y, a set of y-vectors;
!         sy(m,m) stores S'Y;
!         wt(m,m) stores the
!                 Cholesky factorization of (theta*S'S+LD^(-1)L').
!       On exit these arrays are unchanged.
!
!     theta is a double precision variable.
!       On entry theta is the scaling factor specifying B_0 = theta I.
!       On exit theta is unchanged.
!
!     col is an integer variable.
!       On entry col is the actual number of variable metric
!         corrections stored so far.
!       On exit col is unchanged.
!
!     head is an integer variable.
!       On entry head is the location of the first s-vector (or y-vector)
!         in S (or Y).
!       On exit col is unchanged.
!
!     p is a double precision working array of dimension 2m.
!       p will be used to store the vector p = W^(T)d.
!
!     c is a double precision working array of dimension 2m.
!       c will be used to store the vector c = W^(T)(xcp-x).
!
!     wbp is a double precision working array of dimension 2m.
!       wbp will be used to store the row of W corresponding
!         to a breakpoint.
!
!     v is a double precision working array of dimension 2m.
!
!     nseg is an integer variable.
!       On exit nseg records the number of quadratic segments explored
!         in searching for the GCP.
!
!     sg and yg are double precision arrays of dimension m.
!       On entry sg  and yg store S'g and Y'g correspondingly.
!       On exit they are unchanged.
!
!     iprint is an INTEGER variable that must be set by the user.
!       It controls the frequency and type of output generated:
!        iprint<0    no output is generated;
!        iprint=0    print only one line at the last iteration;
!        0<iprint<99 print also f and |proj g| every iprint iterations;
!        iprint=99   print details of every iteration except n-vectors;
!        iprint=100  print also the changes of active set and final x;
!        iprint>100  print details of every iteration including x and g;
!       When iprint > 0, the file iterate.dat will be created to
!                        summarize the iteration.
!
!     sbgnrm is a double precision variable.
!       On entry sbgnrm is the norm of the projected gradient at x.
!       On exit sbgnrm is unchanged.
!
!     info is an integer variable.
!       On entry info is 0.
!       On exit info = 0       for normal return,
!                    = nonzero for abnormal return when the the system
!                              used in routine bmv is singular.
!
!     Subprograms called:
!
!       L-BFGS-B Library ... hpsolb, bmv.
!
!       Linpack ... dscal dcopy, daxpy.
!
!
!     References:
!
!       [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited
!       memory algorithm for bound constrained optimization'',
!       SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208.
!
!       [2] C. Zhu, R.H. Byrd, P. Lu, J. Nocedal, ``L-BFGS-B: FORTRAN
!       Subroutines for Large Scale Bound Constrained Optimization''
!       Tech. Report, NAM-11, EECS Department, Northwestern University,
!       1994.
!
!       (Postscript files of these papers are available via anonymous
!        ftp to eecs.nwu.edu in the directory pub/lbfgs/lbfgs_bcm.)
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     ************
 
      LOGICAL xlower , xupper , bnded
      INTEGER i , j , col2 , nfree , nbreak , pointr , ibp , nleft ,    &
            & ibkmin , iter
      DOUBLE PRECISION f1 , f2 , dt , dtm , tsum , dibp , zibp , dibp2 ,&
                     & bkmin , tu , tl , wmc , wmp , wmw , DDOT , tj ,  &
                     & tj0 , neggi , Sbgnrm , f2_org
      DOUBLE PRECISION ONE , ZERO
      PARAMETER (ONE=1.0D0,ZERO=0.0D0)
 
!     Check the status of the variables, reset iwhere(i) if necessary;
!       compute the Cauchy direction d and the breakpoints t; initialize
!       the derivative f1 and the vector p = W'd (for theta = 1).
 
      IF ( Sbgnrm.LE.ZERO ) THEN
         IF ( Iprint.GE.0 ) WRITE (6,*) 'Subgnorm = 0.  GCP = X.'
         CALL DCOPY(N,X,1,Xcp,1)
         RETURN
      ENDIF
      bnded = .TRUE.
      nfree = N + 1
      nbreak = 0
      ibkmin = 0
      bkmin = ZERO
      col2 = 2*Col
      f1 = ZERO
      IF ( Iprint.GE.99 ) WRITE (6,99001)
99001 FORMAT (/,'---------------- CAUCHY entered-------------------')
 
!     We set p to zero and build it up as we determine d.
 
      DO i = 1 , col2
         P(i) = ZERO
      ENDDO
 
!     In the following loop we determine for each variable its bound
!        status and its breakpoint, and update p accordingly.
!        Smallest breakpoint is identified.
 
      DO i = 1 , N
         neggi = -G(i)
         IF ( Iwhere(i).NE.3 .AND. Iwhere(i).NE.-1 ) THEN
!             if x(i) is not a constant and has bounds,
!             compute the difference between x(i) and its bounds.
            IF ( Nbd(i).LE.2 ) tl = X(i) - L(i)
            IF ( Nbd(i).GE.2 ) tu = U(i) - X(i)
 
!           If a variable is close enough to a bound
!             we treat it as at bound.
            xlower = Nbd(i).LE.2 .AND. tl.LE.ZERO
            xupper = Nbd(i).GE.2 .AND. tu.LE.ZERO
 
!              reset iwhere(i).
            Iwhere(i) = 0
            IF ( xlower ) THEN
               IF ( neggi.LE.ZERO ) Iwhere(i) = 1
            ELSEIF ( xupper ) THEN
               IF ( neggi.GE.ZERO ) Iwhere(i) = 2
            ELSE
               IF ( ABS(neggi).LE.ZERO ) Iwhere(i) = -3
            ENDIF
         ENDIF
         pointr = Head
         IF ( Iwhere(i).NE.0 .AND. Iwhere(i).NE.-1 ) THEN
            D(i) = ZERO
         ELSE
            D(i) = neggi
            f1 = f1 - neggi*neggi
!             calculate p := p - W'e_i* (g_i).
            DO j = 1 , Col
               P(j) = P(j) + Wy(i,pointr)*neggi
               P(Col+j) = P(Col+j) + Ws(i,pointr)*neggi
               pointr = MOD(pointr,M) + 1
            ENDDO
            IF ( Nbd(i).LE.2 .AND. Nbd(i).NE.0 .AND. neggi.LT.ZERO )    &
               & THEN
!                                 x(i) + d(i) is bounded; compute t(i).
               nbreak = nbreak + 1
               Iorder(nbreak) = i
               T(nbreak) = tl/(-neggi)
               IF ( nbreak.EQ.1 .OR. T(nbreak).LT.bkmin ) THEN
                  bkmin = T(nbreak)
                  ibkmin = nbreak
               ENDIF
            ELSEIF ( Nbd(i).GE.2 .AND. neggi.GT.ZERO ) THEN
!                                 x(i) + d(i) is bounded; compute t(i).
               nbreak = nbreak + 1
               Iorder(nbreak) = i
               T(nbreak) = tu/neggi
               IF ( nbreak.EQ.1 .OR. T(nbreak).LT.bkmin ) THEN
                  bkmin = T(nbreak)
                  ibkmin = nbreak
               ENDIF
            ELSE
!                x(i) + d(i) is not bounded.
               nfree = nfree - 1
               Iorder(nfree) = i
               IF ( ABS(neggi).GT.ZERO ) bnded = .FALSE.
            ENDIF
         ENDIF
      ENDDO
 
!     The indices of the nonzero components of d are now stored
!       in iorder(1),...,iorder(nbreak) and iorder(nfree),...,iorder(n).
!       The smallest of the nbreak breakpoints is in t(ibkmin)=bkmin.
 
!                   complete the initialization of p for theta not= one.
      IF ( Theta.NE.ONE ) CALL DSCAL(Col,Theta,P(Col+1),1)
 
!     Initialize GCP xcp = x.
 
      CALL DCOPY(N,X,1,Xcp,1)
 
      IF ( nbreak.EQ.0 .AND. nfree.EQ.N+1 ) THEN
!                  is a zero vector, return with the initial xcp as GCP.
         IF ( Iprint.GT.100 ) WRITE (6,99006) (Xcp(i),i=1,N)
         RETURN
      ENDIF
 
!     Initialize c = W'(xcp - x) = 0.
 
      DO j = 1 , col2
         C(j) = ZERO
      ENDDO
 
!     Initialize derivative f2.
 
      f2 = -Theta*f1
      f2_org = f2
      IF ( Col.GT.0 ) THEN
         CALL BMV(M,Sy,Wt,Col,P,V,Info)
         IF ( Info.NE.0 ) RETURN
         f2 = f2 - DDOT(col2,V,1,P,1)
      ENDIF
      dtm = -f1/f2
      tsum = ZERO
      Nseg = 1
      IF ( Iprint.GE.99 ) WRITE (6,*) 'There are ' , nbreak ,           &
                                     &'  breakpoints '
 
!     If there are no breakpoints, locate the GCP and return.
 
      IF ( nbreak.EQ.0 ) GOTO 200
 
      nleft = nbreak
      iter = 1
 
 
      tj = ZERO
 
!------------------- the beginning of the loop -------------------------
 
 100  CONTINUE
 
!     Find the next smallest breakpoint;
!       compute dt = t(nleft) - t(nleft + 1).
 
      tj0 = tj
      IF ( iter.EQ.1 ) THEN
!         Since we already have the smallest breakpoint we need not do
!         heapsort yet. Often only one breakpoint is used and the
!         cost of heapsort is avoided.
         tj = bkmin
         ibp = Iorder(ibkmin)
      ELSE
         IF ( iter.EQ.2 ) THEN
!             Replace the already used smallest breakpoint with the
!             breakpoint numbered nbreak > nlast, before heapsort call.
            IF ( ibkmin.NE.nbreak ) THEN
               T(ibkmin) = T(nbreak)
               Iorder(ibkmin) = Iorder(nbreak)
            ENDIF
!        Update heap structure of breakpoints
!           (if iter=2, initialize heap).
         ENDIF
         CALL HPSOLB(nleft,T,Iorder,iter-2)
         tj = T(nleft)
         ibp = Iorder(nleft)
      ENDIF
 
      dt = tj - tj0
 
      IF ( dt.NE.ZERO .AND. Iprint.GE.100 ) THEN
         WRITE (6,99002) Nseg , f1 , f2
99002    FORMAT (/,'Piece    ',i3,' --f1, f2 at start point ',1p,       &
               & 2(1x,d11.4))
         WRITE (6,99003) dt
99003    FORMAT ('Distance to the next break point =  ',1p,d11.4)
         WRITE (6,99007) dtm
      ENDIF
 
!     If a minimizer is within this interval, locate the GCP and return.
 
      IF ( dtm.LT.dt ) GOTO 200
 
!     Otherwise fix one variable and
!       reset the corresponding component of d to zero.
 
      tsum = tsum + dt
      nleft = nleft - 1
      iter = iter + 1
      dibp = D(ibp)
      D(ibp) = ZERO
      IF ( dibp.GT.ZERO ) THEN
         zibp = U(ibp) - X(ibp)
         Xcp(ibp) = U(ibp)
         Iwhere(ibp) = 2
      ELSE
         zibp = L(ibp) - X(ibp)
         Xcp(ibp) = L(ibp)
         Iwhere(ibp) = 1
      ENDIF
      IF ( Iprint.GE.100 ) WRITE (6,*) 'Variable  ' , ibp ,             &
                                      &'  is fixed.'
      IF ( nleft.EQ.0 .AND. nbreak.EQ.N ) THEN
!                                             all n variables are fixed,
!                                                return with xcp as GCP.
         dtm = dt
         GOTO 300
      ENDIF
 
!     Update the derivative information.
 
      Nseg = Nseg + 1
      dibp2 = dibp**2
 
!     Update f1 and f2.
 
!        temporarily set f1 and f2 for col=0.
      f1 = f1 + dt*f2 + dibp2 - Theta*dibp*zibp
      f2 = f2 - Theta*dibp2
 
      IF ( Col.GT.0 ) THEN
!                          update c = c + dt*p.
         CALL DAXPY(col2,dt,P,1,C,1)
 
!           choose wbp,
!           the row of W corresponding to the breakpoint encountered.
         pointr = Head
         DO j = 1 , Col
            Wbp(j) = Wy(ibp,pointr)
            Wbp(Col+j) = Theta*Ws(ibp,pointr)
            pointr = MOD(pointr,M) + 1
         ENDDO
 
!           compute (wbp)Mc, (wbp)Mp, and (wbp)M(wbp)'.
         CALL BMV(M,Sy,Wt,Col,Wbp,V,Info)
         IF ( Info.NE.0 ) RETURN
         wmc = DDOT(col2,C,1,V,1)
         wmp = DDOT(col2,P,1,V,1)
         wmw = DDOT(col2,Wbp,1,V,1)
 
!           update p = p - dibp*wbp.
         CALL DAXPY(col2,-dibp,Wbp,1,P,1)
 
!           complete updating f1 and f2 while col > 0.
         f1 = f1 + dibp*wmc
         f2 = f2 + 2.0D0*dibp*wmp - dibp2*wmw
      ENDIF
 
      f2 = MAX(Epsmch*f2_org,f2)
      IF ( nleft.GT.0 ) THEN
         dtm = -f1/f2
         GOTO 100
!                 to repeat the loop for unsearched intervals.
      ELSEIF ( bnded ) THEN
         f1 = ZERO
         f2 = ZERO
         dtm = ZERO
      ELSE
         dtm = -f1/f2
      ENDIF
 
!------------------- the end of the loop -------------------------------
 
 200  CONTINUE
      IF ( Iprint.GE.99 ) THEN
         WRITE (6,*)
         WRITE (6,*) 'GCP found in this segment'
         WRITE (6,99004) Nseg , f1 , f2
99004    FORMAT ('Piece    ',i3,' --f1, f2 at start point ',1p,         &
               & 2(1x,d11.4))
         WRITE (6,99007) dtm
      ENDIF
      IF ( dtm.LE.ZERO ) dtm = ZERO
      tsum = tsum + dtm
 
!     Move free variables (i.e., the ones w/o breakpoints) and
!       the variables whose breakpoints haven't been reached.
 
      CALL DAXPY(N,tsum,D,1,Xcp,1)
 
 300  CONTINUE
 
!     Update c = c + dtm*p = W'(x^c - x)
!       which will be used in computing r = Z'(B(x^c - x) + g).
 
      IF ( Col.GT.0 ) CALL DAXPY(col2,dtm,P,1,C,1)
      IF ( Iprint.GT.100 ) WRITE (6,99006) (Xcp(i),i=1,N)
      IF ( Iprint.GE.99 ) WRITE (6,99005)
99005 FORMAT (/,'---------------- exit CAUCHY----------------------',/)
 
      CONTINUE
 
99006 FORMAT ('Cauchy X =  ',/,(4x,1p,6(1x,d11.4)))
99007 FORMAT ('Distance to the stationary point =  ',1p,d11.4)
 
      END
 
!====================== The end of cauchy ==============================
 
      SUBROUTINE CMPRLB(N,M,X,G,Ws,Wy,Sy,Wt,Z,R,Wa,Index,Theta,Col,Head,&
                      & Nfree,Cnstnd,Info)
      IMPLICIT NONE
!*--CMPRLB1724
 
      LOGICAL Cnstnd
      INTEGER N , M , Col , Head , Nfree , Info , Index(N)
      DOUBLE PRECISION Theta , X(N) , G(N) , Z(N) , R(N) , Wa(4*M) ,    &
                     & Ws(N,M) , Wy(N,M) , Sy(M,M) , Wt(M,M)
 
!     ************
!
!     Subroutine cmprlb
!
!       This subroutine computes r=-Z'B(xcp-xk)-Z'g by using
!         wa(2m+1)=W'(xcp-x) from subroutine cauchy.
!
!     Subprograms called:
!
!       L-BFGS-B Library ... bmv.
!
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     ************
 
      INTEGER i , j , k , pointr
      DOUBLE PRECISION a1 , a2
 
      IF ( .NOT.Cnstnd .AND. Col.GT.0 ) THEN
         DO i = 1 , N
            R(i) = -G(i)
         ENDDO
      ELSE
         DO i = 1 , Nfree
            k = Index(i)
            R(i) = -Theta*(Z(k)-X(k)) - G(k)
         ENDDO
         CALL BMV(M,Sy,Wt,Col,Wa(2*M+1),Wa(1),Info)
         IF ( Info.NE.0 ) THEN
            Info = -8
            RETURN
         ENDIF
         pointr = Head
         DO j = 1 , Col
            a1 = Wa(j)
            a2 = Theta*Wa(Col+j)
            DO i = 1 , Nfree
               k = Index(i)
               R(i) = R(i) + Wy(k,pointr)*a1 + Ws(k,pointr)*a2
            ENDDO
            pointr = MOD(pointr,M) + 1
         ENDDO
      ENDIF
 
      CONTINUE
 
      END
 
!======================= The end of cmprlb =============================
 
      SUBROUTINE ERRCLB(N,M,Factr,L,U,Nbd,Task,Info,K)
      IMPLICIT NONE
!*--ERRCLB1793
 
      CHARACTER*60 Task
      INTEGER N , M , Info , K , Nbd(N)
      DOUBLE PRECISION Factr , L(N) , U(N)
 
!     ************
!
!     Subroutine errclb
!
!     This subroutine checks the validity of the input data.
!
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     ************
 
      INTEGER i
      DOUBLE PRECISION ZERO
      PARAMETER (ZERO=0.0D0)
 
!     Check the input arguments for errors.
 
      IF ( N.LE.0 ) Task = 'ERROR: N .LE. 0'
      IF ( M.LE.0 ) Task = 'ERROR: M .LE. 0'
      IF ( Factr.LT.ZERO ) Task = 'ERROR: FACTR .LT. 0'
 
!     Check the validity of the arrays nbd(i), u(i), and l(i).
 
      DO i = 1 , N
         IF ( Nbd(i).LT.0 .OR. Nbd(i).GT.3 ) THEN
!                                                   return
            Task = 'ERROR: INVALID NBD'
            Info = -6
            K = i
         ENDIF
         IF ( Nbd(i).EQ.2 ) THEN
            IF ( L(i).GT.U(i) ) THEN
!                                    return
               Task = 'ERROR: NO FEASIBLE SOLUTION'
               Info = -7
               K = i
            ENDIF
         ENDIF
      ENDDO
 
      CONTINUE
 
      END
 
!======================= The end of errclb =============================
 
      SUBROUTINE FORMK(N,Nsub,Ind,Nenter,Ileave,Indx2,Iupdat,Updatd,Wn, &
                     & Wn1,M,Ws,Wy,Sy,Theta,Col,Head,Info)
      IMPLICIT NONE
!*--FORMK1857
 
      INTEGER N , Nsub , M , Col , Head , Nenter , Ileave , Iupdat ,    &
            & Info , Ind(N) , Indx2(N)
      DOUBLE PRECISION Theta , Wn(2*M,2*M) , Wn1(2*M,2*M) , Ws(N,M) ,   &
                     & Wy(N,M) , Sy(M,M)
      LOGICAL Updatd
 
!     ************
!
!     Subroutine formk
!
!     This subroutine forms  the LEL^T factorization of the indefinite
!
!       matrix    K = [-D -Y'ZZ'Y/theta     L_a'-R_z'  ]
!                     [L_a -R_z           theta*S'AA'S ]
!                                                    where E = [-I  0]
!                                                              [ 0  I]
!     The matrix K can be shown to be equal to the matrix M^[-1]N
!       occurring in section 5.1 of [1], as well as to the matrix
!       Mbar^[-1] Nbar in section 5.3.
!
!     n is an integer variable.
!       On entry n is the dimension of the problem.
!       On exit n is unchanged.
!
!     nsub is an integer variable
!       On entry nsub is the number of subspace variables in free set.
!       On exit nsub is not changed.
!
!     ind is an integer array of dimension nsub.
!       On entry ind specifies the indices of subspace variables.
!       On exit ind is unchanged.
!
!     nenter is an integer variable.
!       On entry nenter is the number of variables entering the
!         free set.
!       On exit nenter is unchanged.
!
!     ileave is an integer variable.
!       On entry indx2(ileave),...,indx2(n) are the variables leaving
!         the free set.
!       On exit ileave is unchanged.
!
!     indx2 is an integer array of dimension n.
!       On entry indx2(1),...,indx2(nenter) are the variables entering
!         the free set, while indx2(ileave),...,indx2(n) are the
!         variables leaving the free set.
!       On exit indx2 is unchanged.
!
!     iupdat is an integer variable.
!       On entry iupdat is the total number of BFGS updates made so far.
!       On exit iupdat is unchanged.
!
!     updatd is a logical variable.
!       On entry 'updatd' is true if the L-BFGS matrix is updatd.
!       On exit 'updatd' is unchanged.
!
!     wn is a double precision array of dimension 2m x 2m.
!       On entry wn is unspecified.
!       On exit the upper triangle of wn stores the LEL^T factorization
!         of the 2*col x 2*col indefinite matrix
!                     [-D -Y'ZZ'Y/theta     L_a'-R_z'  ]
!                     [L_a -R_z           theta*S'AA'S ]
!
!     wn1 is a double precision array of dimension 2m x 2m.
!       On entry wn1 stores the lower triangular part of
!                     [Y' ZZ'Y   L_a'+R_z']
!                     [L_a+R_z   S'AA'S   ]
!         in the previous iteration.
!       On exit wn1 stores the corresponding updated matrices.
!       The purpose of wn1 is just to store these inner products
!       so they can be easily updated and inserted into wn.
!
!     m is an integer variable.
!       On entry m is the maximum number of variable metric corrections
!         used to define the limited memory matrix.
!       On exit m is unchanged.
!
!     ws, wy, sy, and wtyy are double precision arrays;
!     theta is a double precision variable;
!     col is an integer variable;
!     head is an integer variable.
!       On entry they store the information defining the
!                                          limited memory BFGS matrix:
!         ws(n,m) stores S, a set of s-vectors;
!         wy(n,m) stores Y, a set of y-vectors;
!         sy(m,m) stores S'Y;
!         wtyy(m,m) stores the Cholesky factorization
!                                   of (theta*S'S+LD^(-1)L')
!         theta is the scaling factor specifying B_0 = theta I;
!         col is the number of variable metric corrections stored;
!         head is the location of the 1st s- (or y-) vector in S (or Y).
!       On exit they are unchanged.
!
!     info is an integer variable.
!       On entry info is unspecified.
!       On exit info =  0 for normal return;
!                    = -1 when the 1st Cholesky factorization failed;
!                    = -2 when the 2st Cholesky factorization failed.
!
!     Subprograms called:
!
!       Linpack ... dcopy, dpofa, dtrsl.
!
!
!     References:
!       [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited
!       memory algorithm for bound constrained optimization'',
!       SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208.
!
!       [2] C. Zhu, R.H. Byrd, P. Lu, J. Nocedal, ``L-BFGS-B: a
!       limited memory FORTRAN code for solving bound constrained
!       optimization problems'', Tech. Report, NAM-11, EECS Department,
!       Northwestern University, 1994.
!
!       (Postscript files of these papers are available via anonymous
!        ftp to eecs.nwu.edu in the directory pub/lbfgs/lbfgs_bcm.)
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     ************
 
      INTEGER m2 , ipntr , jpntr , iy , is , jy , js , is1 , js1 , k1 , &
            & i , k , col2 , pbegin , pend , dbegin , dend , upcl
      DOUBLE PRECISION DDOT , temp1 , temp2 , temp3 , temp4
      DOUBLE PRECISION ZERO
      PARAMETER (ZERO=0.0D0)
 
!     Form the lower triangular part of
!               WN1 = [Y' ZZ'Y   L_a'+R_z']
!                     [L_a+R_z   S'AA'S   ]
!        where L_a is the strictly lower triangular part of S'AA'Y
!              R_z is the upper triangular part of S'ZZ'Y.
 
      IF ( Updatd ) THEN
         IF ( Iupdat.GT.M ) THEN
!                                 shift old part of WN1.
            DO jy = 1 , M - 1
               js = M + jy
               CALL DCOPY(M-jy,Wn1(jy+1,jy+1),1,Wn1(jy,jy),1)
               CALL DCOPY(M-jy,Wn1(js+1,js+1),1,Wn1(js,js),1)
               CALL DCOPY(M-1,Wn1(M+2,jy+1),1,Wn1(M+1,jy),1)
            ENDDO
         ENDIF
 
!          put new rows in blocks (1,1), (2,1) and (2,2).
         pbegin = 1
         pend = Nsub
         dbegin = Nsub + 1
         dend = N
         iy = Col
         is = M + Col
         ipntr = Head + Col - 1
         IF ( ipntr.GT.M ) ipntr = ipntr - M
         jpntr = Head
         DO jy = 1 , Col
            js = M + jy
            temp1 = ZERO
            temp2 = ZERO
            temp3 = ZERO
!             compute element jy of row 'col' of Y'ZZ'Y
            DO k = pbegin , pend
               k1 = Ind(k)
               temp1 = temp1 + Wy(k1,ipntr)*Wy(k1,jpntr)
            ENDDO
!             compute elements jy of row 'col' of L_a and S'AA'S
            DO k = dbegin , dend
               k1 = Ind(k)
               temp2 = temp2 + Ws(k1,ipntr)*Ws(k1,jpntr)
               temp3 = temp3 + Ws(k1,ipntr)*Wy(k1,jpntr)
            ENDDO
            Wn1(iy,jy) = temp1
            Wn1(is,js) = temp2
            Wn1(is,jy) = temp3
            jpntr = MOD(jpntr,M) + 1
         ENDDO
 
!          put new column in block (2,1).
         jy = Col
         jpntr = Head + Col - 1
         IF ( jpntr.GT.M ) jpntr = jpntr - M
         ipntr = Head
         DO i = 1 , Col
            is = M + i
            temp3 = ZERO
!             compute element i of column 'col' of R_z
            DO k = pbegin , pend
               k1 = Ind(k)
               temp3 = temp3 + Ws(k1,ipntr)*Wy(k1,jpntr)
            ENDDO
            ipntr = MOD(ipntr,M) + 1
            Wn1(is,jy) = temp3
         ENDDO
         upcl = Col - 1
      ELSE
         upcl = Col
      ENDIF
 
!       modify the old parts in blocks (1,1) and (2,2) due to changes
!       in the set of free variables.
      ipntr = Head
      DO iy = 1 , upcl
         is = M + iy
         jpntr = Head
         DO jy = 1 , iy
            js = M + jy
            temp1 = ZERO
            temp2 = ZERO
            temp3 = ZERO
            temp4 = ZERO
            DO k = 1 , Nenter
               k1 = Indx2(k)
               temp1 = temp1 + Wy(k1,ipntr)*Wy(k1,jpntr)
               temp2 = temp2 + Ws(k1,ipntr)*Ws(k1,jpntr)
            ENDDO
            DO k = Ileave , N
               k1 = Indx2(k)
               temp3 = temp3 + Wy(k1,ipntr)*Wy(k1,jpntr)
               temp4 = temp4 + Ws(k1,ipntr)*Ws(k1,jpntr)
            ENDDO
            Wn1(iy,jy) = Wn1(iy,jy) + temp1 - temp3
            Wn1(is,js) = Wn1(is,js) - temp2 + temp4
            jpntr = MOD(jpntr,M) + 1
         ENDDO
         ipntr = MOD(ipntr,M) + 1
      ENDDO
 
!       modify the old parts in block (2,1).
      ipntr = Head
      DO is = M + 1 , M + upcl
         jpntr = Head
         DO jy = 1 , upcl
            temp1 = ZERO
            temp3 = ZERO
            DO k = 1 , Nenter
               k1 = Indx2(k)
               temp1 = temp1 + Ws(k1,ipntr)*Wy(k1,jpntr)
            ENDDO
            DO k = Ileave , N
               k1 = Indx2(k)
               temp3 = temp3 + Ws(k1,ipntr)*Wy(k1,jpntr)
            ENDDO
            IF ( is.LE.jy+M ) THEN
               Wn1(is,jy) = Wn1(is,jy) + temp1 - temp3
            ELSE
               Wn1(is,jy) = Wn1(is,jy) - temp1 + temp3
            ENDIF
            jpntr = MOD(jpntr,M) + 1
         ENDDO
         ipntr = MOD(ipntr,M) + 1
      ENDDO
 
!     Form the upper triangle of WN = [D+Y' ZZ'Y/theta   -L_a'+R_z' ]
!                                     [-L_a +R_z        S'AA'S*theta]
 
      m2 = 2*M
      DO iy = 1 , Col
         is = Col + iy
         is1 = M + iy
         DO jy = 1 , iy
            js = Col + jy
            js1 = M + jy
            Wn(jy,iy) = Wn1(iy,jy)/Theta
            Wn(js,is) = Wn1(is1,js1)*Theta
         ENDDO
         DO jy = 1 , iy - 1
            Wn(jy,is) = -Wn1(is1,jy)
         ENDDO
         DO jy = iy , Col
            Wn(jy,is) = Wn1(is1,jy)
         ENDDO
         Wn(iy,iy) = Wn(iy,iy) + Sy(iy,iy)
      ENDDO
 
!     Form the upper triangle of WN= [  LL'            L^-1(-L_a'+R_z')]
!                                    [(-L_a +R_z)L'^-1   S'AA'S*theta  ]
 
!        first Cholesky factor (1,1) block of wn to get LL'
!                          with L' stored in the upper triangle of wn.
      CALL DPOFA(Wn,m2,Col,Info)
      IF ( Info.NE.0 ) THEN
         Info = -1
         RETURN
      ENDIF
!        then form L^-1(-L_a'+R_z') in the (1,2) block.
      col2 = 2*Col
      DO js = Col + 1 , col2
         CALL DTRSL(Wn,m2,Col,Wn(1,js),11,Info)
      ENDDO
 
!     Form S'AA'S*theta + (L^-1(-L_a'+R_z'))'L^-1(-L_a'+R_z') in the
!        upper triangle of (2,2) block of wn.
 
 
      DO is = Col + 1 , col2
         DO js = is , col2
            Wn(is,js) = Wn(is,js) + DDOT(Col,Wn(1,is),1,Wn(1,js),1)
         ENDDO
      ENDDO
 
!     Cholesky factorization of (2,2) block of wn.
 
      CALL DPOFA(Wn(Col+1,Col+1),m2,Col,Info)
      IF ( Info.NE.0 ) THEN
         Info = -2
         RETURN
      ENDIF
 
      CONTINUE
 
      END
 
!======================= The end of formk ==============================
 
      SUBROUTINE FORMT(M,Wt,Sy,Ss,Col,Theta,Info)
      IMPLICIT NONE
!*--FORMT2183
 
      INTEGER M , Col , Info
      DOUBLE PRECISION Theta , Wt(M,M) , Sy(M,M) , Ss(M,M)
 
!     ************
!
!     Subroutine formt
!
!       This subroutine forms the upper half of the pos. def. and symm.
!         T = theta*SS + L*D^(-1)*L', stores T in the upper triangle
!         of the array wt, and performs the Cholesky factorization of T
!         to produce J*J', with J' stored in the upper triangle of wt.
!
!     Subprograms called:
!
!       Linpack ... dpofa.
!
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     ************
 
      INTEGER i , j , k , k1
      DOUBLE PRECISION ddum
      DOUBLE PRECISION ZERO
      PARAMETER (ZERO=0.0D0)
 
 
!     Form the upper half of  T = theta*SS + L*D^(-1)*L',
!        store T in the upper triangle of the array wt.
 
      DO j = 1 , Col
         Wt(1,j) = Theta*Ss(1,j)
      ENDDO
      DO i = 2 , Col
         DO j = i , Col
            k1 = MIN(i,j) - 1
            ddum = ZERO
            DO k = 1 , k1
               ddum = ddum + Sy(i,k)*Sy(j,k)/Sy(k,k)
            ENDDO
            Wt(i,j) = ddum + Theta*Ss(i,j)
         ENDDO
      ENDDO
 
!     Cholesky factorize T to J*J' with
!        J' stored in the upper triangle of wt.
 
      CALL DPOFA(Wt,M,Col,Info)
      IF ( Info.NE.0 ) Info = -3
 
      CONTINUE
 
      END
 
!======================= The end of formt ==============================
 
      SUBROUTINE FREEV(N,Nfree,Index,Nenter,Ileave,Indx2,Iwhere,Wrk,    &
                     & Updatd,Cnstnd,Iprint,Iter)
      IMPLICIT NONE
!*--FREEV2253
 
      INTEGER N , Nfree , Nenter , Ileave , Iprint , Iter , Index(N) ,  &
            & Indx2(N) , Iwhere(N)
      LOGICAL Wrk , Updatd , Cnstnd
 
!     ************
!
!     Subroutine freev
!
!     This subroutine counts the entering and leaving variables when
!       iter > 0, and finds the index set of free and active variables
!       at the GCP.
!
!     cnstnd is a logical variable indicating whether bounds are present
!
!     index is an integer array of dimension n
!       for i=1,...,nfree, index(i) are the indices of free variables
!       for i=nfree+1,...,n, index(i) are the indices of bound variables
!       On entry after the first iteration, index gives
!         the free variables at the previous iteration.
!       On exit it gives the free variables based on the determination
!         in cauchy using the array iwhere.
!
!     indx2 is an integer array of dimension n
!       On entry indx2 is unspecified.
!       On exit with iter>0, indx2 indicates which variables
!          have changed status since the previous iteration.
!       For i= 1,...,nenter, indx2(i) have changed from bound to free.
!       For i= ileave+1,...,n, indx2(i) have changed from free to bound.
!
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     ************
 
      INTEGER iact , i , k
 
      Nenter = 0
      Ileave = N + 1
      IF ( Iter.GT.0 .AND. Cnstnd ) THEN
!                           count the entering and leaving variables.
         DO i = 1 , Nfree
            k = Index(i)
 
!            write(6,*) ' k  = index(i) ', k
!            write(6,*) ' index = ', i
 
            IF ( Iwhere(k).GT.0 ) THEN
               Ileave = Ileave - 1
               Indx2(Ileave) = k
               IF ( Iprint.GE.100 ) WRITE (6,*) 'Variable ' , k ,       &
                   &' leaves the set of free variables'
            ENDIF
         ENDDO
         DO i = 1 + Nfree , N
            k = Index(i)
            IF ( Iwhere(k).LE.0 ) THEN
               Nenter = Nenter + 1
               Indx2(Nenter) = k
               IF ( Iprint.GE.100 ) WRITE (6,*) 'Variable ' , k ,       &
                   &' enters the set of free variables'
            ENDIF
         ENDDO
         IF ( Iprint.GE.99 ) WRITE (6,*) N + 1 - Ileave ,               &
                                   &' variables leave; ' , Nenter ,     &
                                   &' variables enter'
      ENDIF
      Wrk = (Ileave.LT.N+1) .OR. (Nenter.GT.0) .OR. Updatd
 
!     Find the index set of free and active variables at the GCP.
 
      Nfree = 0
      iact = N + 1
      DO i = 1 , N
         IF ( Iwhere(i).LE.0 ) THEN
            Nfree = Nfree + 1
            Index(Nfree) = i
         ELSE
            iact = iact - 1
            Index(iact) = i
         ENDIF
      ENDDO
      IF ( Iprint.GE.99 ) WRITE (6,*) Nfree ,                           &
                                     &' variables are free at GCP ' ,   &
                                    & Iter + 1
 
      CONTINUE
 
      END
 
!======================= The end of freev ==============================
 
      SUBROUTINE HPSOLB(N,T,Iorder,Iheap)
      IMPLICIT NONE
!*--HPSOLB2357
      INTEGER Iheap , N , Iorder(N)
      DOUBLE PRECISION T(N)
 
!     ************
!
!     Subroutine hpsolb
!
!     This subroutine sorts out the least element of t, and puts the
!       remaining elements of t in a heap.
!
!     n is an integer variable.
!       On entry n is the dimension of the arrays t and iorder.
!       On exit n is unchanged.
!
!     t is a double precision array of dimension n.
!       On entry t stores the elements to be sorted,
!       On exit t(n) stores the least elements of t, and t(1) to t(n-1)
!         stores the remaining elements in the form of a heap.
!
!     iorder is an integer array of dimension n.
!       On entry iorder(i) is the index of t(i).
!       On exit iorder(i) is still the index of t(i), but iorder may be
!         permuted in accordance with t.
!
!     iheap is an integer variable specifying the task.
!       On entry iheap should be set as follows:
!         iheap .eq. 0 if t(1) to t(n) is not in the form of a heap,
!         iheap .ne. 0 if otherwise.
!       On exit iheap is unchanged.
!
!
!     References:
!       Algorithm 232 of CACM (J. W. J. Williams): HEAPSORT.
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!     ************
 
      INTEGER i , j , k , indxin , indxou
      DOUBLE PRECISION ddum , out
 
      IF ( Iheap.EQ.0 ) THEN
 
!        Rearrange the elements t(1) to t(n) to form a heap.
 
         DO k = 2 , N
            ddum = T(k)
            indxin = Iorder(k)
 
!           Add ddum to the heap.
            i = k
 20         CONTINUE
            IF ( i.GT.1 ) THEN
               j = i/2
               IF ( ddum.LT.T(j) ) THEN
                  T(i) = T(j)
                  Iorder(i) = Iorder(j)
                  i = j
                  GOTO 20
               ENDIF
            ENDIF
            T(i) = ddum
            Iorder(i) = indxin
         ENDDO
      ENDIF
 
!     Assign to 'out' the value of t(1), the least member of the heap,
!        and rearrange the remaining members to form a heap as
!        elements 1 to n-1 of t.
 
      IF ( N.GT.1 ) THEN
         i = 1
         out = T(1)
         indxou = Iorder(1)
         ddum = T(N)
         indxin = Iorder(N)
 
!        Restore the heap
 50      CONTINUE
         j = i + i
         IF ( j.LE.N-1 ) THEN
            IF ( T(j+1).LT.T(j) ) j = j + 1
            IF ( T(j).LT.ddum ) THEN
               T(i) = T(j)
               Iorder(i) = Iorder(j)
               i = j
               GOTO 50
            ENDIF
         ENDIF
         T(i) = ddum
         Iorder(i) = indxin
 
!     Put the least member in t(n).
 
         T(N) = out
         Iorder(N) = indxou
      ENDIF
 
      CONTINUE
 
      END
 
!====================== The end of hpsolb ==============================
 
      SUBROUTINE LNSRLB(N,L,U,Nbd,X,F,Fold,Gd,Gdold,G,D,R,T,Z,Stp,Dnorm,&
                      & Dtd,Xstep,Stpmx,Iter,Ifun,Iback,Nfgv,Info,Task, &
                      & Boxed,Cnstnd,Csave,Isave,Dsave)
      IMPLICIT NONE
!*--LNSRLB2474
 
      CHARACTER*60 Task , Csave
      LOGICAL Boxed , Cnstnd
      INTEGER N , Iter , Ifun , Iback , Nfgv , Info , Nbd(N) , Isave(2)
      DOUBLE PRECISION F , Fold , Gd , Gdold , Stp , Dnorm , Dtd ,      &
                     & Xstep , Stpmx , X(N) , L(N) , U(N) , G(N) ,      &
                     & D(N) , R(N) , T(N) , Z(N) , Dsave(13)
!     **********
!
!     Subroutine lnsrlb
!
!     This subroutine calls subroutine dcsrch from the Minpack2 library
!       to perform the line search.  Subroutine dscrch is safeguarded so
!       that all trial points lie within the feasible region.
!
!     Subprograms called:
!
!       Minpack2 Library ... dcsrch.
!
!       Linpack ... dtrsl, ddot.
!
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     **********
 
      INTEGER i
      DOUBLE PRECISION DDOT , a1 , a2
      DOUBLE PRECISION ONE , ZERO , BIG
      PARAMETER (ONE=1.0D0,ZERO=0.0D0,BIG=1.0D+10)
      DOUBLE PRECISION FTOL , GTOL , XTOL
      PARAMETER (FTOL=1.0D-3,GTOL=0.9D0,XTOL=0.1D0)
 
      IF ( Task(1:5).EQ.'FG_LN' ) GOTO 100
 
      Dtd = DDOT(N,D,1,D,1)
      Dnorm = SQRT(Dtd)
 
!     Determine the maximum step length.
 
      Stpmx = BIG
      IF ( Cnstnd ) THEN
         IF ( Iter.EQ.0 ) THEN
            Stpmx = ONE
         ELSE
            DO i = 1 , N
               a1 = D(i)
               IF ( Nbd(i).NE.0 ) THEN
                  IF ( a1.LT.ZERO .AND. Nbd(i).LE.2 ) THEN
                     a2 = L(i) - X(i)
                     IF ( a2.GE.ZERO ) THEN
                        Stpmx = ZERO
                     ELSEIF ( a1*Stpmx.LT.a2 ) THEN
                        Stpmx = a2/a1
                     ENDIF
                  ELSEIF ( a1.GT.ZERO .AND. Nbd(i).GE.2 ) THEN
                     a2 = U(i) - X(i)
                     IF ( a2.LE.ZERO ) THEN
                        Stpmx = ZERO
                     ELSEIF ( a1*Stpmx.GT.a2 ) THEN
                        Stpmx = a2/a1
                     ENDIF
                  ENDIF
               ENDIF
            ENDDO
         ENDIF
      ENDIF
 
      IF ( Iter.EQ.0 .AND. .NOT.Boxed ) THEN
         Stp = MIN(ONE/Dnorm,Stpmx)
      ELSE
         Stp = ONE
      ENDIF
 
      CALL DCOPY(N,X,1,T,1)
      CALL DCOPY(N,G,1,R,1)
      Fold = F
      Ifun = 0
      Iback = 0
      Csave = 'START'
 100  CONTINUE
      Gd = DDOT(N,G,1,D,1)
      IF ( Ifun.EQ.0 ) THEN
         Gdold = Gd
         IF ( Gd.GE.ZERO ) THEN
!                               the directional derivative >=0.
!                               Line search is impossible.
            WRITE (6,*) ' ascent direction in projection gd = ' , Gd
            Info = -4
            RETURN
         ENDIF
      ENDIF
 
      CALL DCSRCH(F,Gd,Stp,FTOL,GTOL,XTOL,ZERO,Stpmx,Csave,Isave,Dsave)
 
      Xstep = Stp*Dnorm
      IF ( Csave(1:4).NE.'CONV' .AND. Csave(1:4).NE.'WARN' ) THEN
         Task = 'FG_LNSRCH'
         Ifun = Ifun + 1
         Nfgv = Nfgv + 1
         Iback = Ifun - 1
         IF ( Stp.EQ.ONE ) THEN
            CALL DCOPY(N,Z,1,X,1)
         ELSE
            DO i = 1 , N
               X(i) = Stp*D(i) + T(i)
            ENDDO
         ENDIF
      ELSE
         Task = 'NEW_X'
      ENDIF
 
      CONTINUE
 
      END
 
!======================= The end of lnsrlb =============================
 
      SUBROUTINE MATUPD(N,M,Ws,Wy,Sy,Ss,D,R,Itail,Iupdat,Col,Head,Theta,&
                      & Rr,Dr,Stp,Dtd)
      IMPLICIT NONE
!*--MATUPD2605
 
      INTEGER N , M , Itail , Iupdat , Col , Head
      DOUBLE PRECISION Theta , Rr , Dr , Stp , Dtd , D(N) , R(N) ,      &
                     & Ws(N,M) , Wy(N,M) , Sy(M,M) , Ss(M,M)
 
!     ************
!
!     Subroutine matupd
!
!       This subroutine updates matrices WS and WY, and forms the
!         middle matrix in B.
!
!     Subprograms called:
!
!       Linpack ... dcopy, ddot.
!
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     ************
 
      INTEGER j , pointr
      DOUBLE PRECISION DDOT
      DOUBLE PRECISION ONE
      PARAMETER (ONE=1.0D0)
 
!     Set pointers for matrices WS and WY.
 
      IF ( Iupdat.LE.M ) THEN
         Col = Iupdat
         Itail = MOD(Head+Iupdat-2,M) + 1
      ELSE
         Itail = MOD(Itail,M) + 1
         Head = MOD(Head,M) + 1
      ENDIF
 
!     Update matrices WS and WY.
 
      CALL DCOPY(N,D,1,Ws(1,Itail),1)
      CALL DCOPY(N,R,1,Wy(1,Itail),1)
 
!     Set theta=yy/ys.
 
      Theta = Rr/Dr
 
!     Form the middle matrix in B.
 
!        update the upper triangle of SS,
!                                         and the lower triangle of SY:
      IF ( Iupdat.GT.M ) THEN
!                              move old information
         DO j = 1 , Col - 1
            CALL DCOPY(j,Ss(2,j+1),1,Ss(1,j),1)
            CALL DCOPY(Col-j,Sy(j+1,j+1),1,Sy(j,j),1)
         ENDDO
      ENDIF
!        add new information: the last row of SY
!                                             and the last column of SS:
      pointr = Head
      DO j = 1 , Col - 1
         Sy(Col,j) = DDOT(N,D,1,Wy(1,pointr),1)
         Ss(j,Col) = DDOT(N,Ws(1,pointr),1,D,1)
         pointr = MOD(pointr,M) + 1
      ENDDO
      IF ( Stp.EQ.ONE ) THEN
         Ss(Col,Col) = Dtd
      ELSE
         Ss(Col,Col) = Stp*Stp*Dtd
      ENDIF
      Sy(Col,Col) = Dr
 
      CONTINUE
 
      END
 
!======================= The end of matupd =============================
 
      SUBROUTINE PRN1LB(N,M,L,U,X,Iprint,Itfile,Epsmch)
      IMPLICIT NONE
!*--PRN1LB2694
 
      INTEGER N , M , Iprint , Itfile
      DOUBLE PRECISION Epsmch , X(N) , L(N) , U(N)
 
!     ************
!
!     Subroutine prn1lb
!
!     This subroutine prints the input data, initial point, upper and
!       lower bounds of each variable, machine precision, as well as
!       the headings of the output.
!
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     ************
 
      INTEGER i
 
      IF ( Iprint.GE.0 ) THEN
         WRITE (6,99001) Epsmch
99001    FORMAT ('RUNNING THE L-BFGS-B CODE',/,/,'           * * *',/,/,&
                &'Machine precision =',1p,d10.3)
         WRITE (6,*) 'N = ' , N , '    M = ' , M
         IF ( Iprint.GE.1 ) THEN
            WRITE (Itfile,99002) Epsmch
99002       FORMAT ('RUNNING THE L-BFGS-B CODE',/,/,                    &
                   &'it    = iteration number',/,                       &
                   &'nf    = number of function evaluations',/,         &
         &'nseg  = number of segments explored during the Cauchy search'&
        & ,/,                                                           &
      &'nact  = number of active bounds at the generalized Cauchy point'&
     & ,/,                                                              &
      &'sub   = manner in which the subspace minimization terminated:', &
     & /,'        con = converged, bnd = a bound was reached',/,        &
      &'itls  = number of iterations performed in the line search',/,   &
      &'stepl = step length used',/,                                    &
      &'tstep = norm of the displacement (total step)',/,               &
      &'projg = norm of the projected gradient',/,                      &
      &'f     = function value',/,/,'           * * *',/,/,             &
      &'Machine precision =',1p,d10.3)
            WRITE (Itfile,*) 'N = ' , N , '    M = ' , M
            WRITE (Itfile,99003)
99003       FORMAT (/,3x,'it',3x,'nf',2x,'nseg',2x,'nact',2x,'sub',2x,  &
                   &'itls',2x,'stepl',4x,'tstep',5x,'projg',8x,'f')
            IF ( Iprint.GT.100 ) THEN
               WRITE (6,99004) 'L =' , (L(i),i=1,N)
               WRITE (6,99004) 'X0 =' , (X(i),i=1,N)
               WRITE (6,99004) 'U =' , (U(i),i=1,N)
            ENDIF
         ENDIF
      ENDIF
 
      CONTINUE
 
99004 FORMAT (/,a4,1p,6(1x,d11.4),/,(4x,1p,6(1x,d11.4)))
 
      END
 
!======================= The end of prn1lb =============================
 
      SUBROUTINE PRN2LB(N,X,F,G,Iprint,Itfile,Iter,Nfgv,Nact,Sbgnrm,    &
                      & Nseg,Word,Iword,Iback,Stp,Xstep)
      IMPLICIT NONE
!*--PRN2LB2768
 
      CHARACTER*3 Word
      INTEGER N , Iprint , Itfile , Iter , Nfgv , Nact , Nseg , Iword , &
            & Iback
      DOUBLE PRECISION F , Sbgnrm , Stp , Xstep , X(N) , G(N)
 
!     ************
!
!     Subroutine prn2lb
!
!     This subroutine prints out new information after a successful
!       line search.
!
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     ************
 
      INTEGER i , imod
 
!           'word' records the status of subspace solutions.
      IF ( Iword.EQ.0 ) THEN
!                            the subspace minimization converged.
         Word = 'con'
      ELSEIF ( Iword.EQ.1 ) THEN
!                          the subspace minimization stopped at a bound.
         Word = 'bnd'
      ELSEIF ( Iword.EQ.5 ) THEN
!                             the truncated Newton step has been used.
         Word = 'TNT'
      ELSE
         Word = '---'
      ENDIF
      IF ( Iprint.GE.99 ) THEN
         WRITE (6,*) 'LINE SEARCH' , Iback , ' times; norm of step = ' ,&
                   & Xstep
         WRITE (6,99003) Iter , F , Sbgnrm
         IF ( Iprint.GT.100 ) THEN
            WRITE (6,99002) 'X =' , (X(i),i=1,N)
            WRITE (6,99002) 'G =' , (G(i),i=1,N)
         ENDIF
      ELSEIF ( Iprint.GT.0 ) THEN
         imod = MOD(Iter,Iprint)
         IF ( imod.EQ.0 ) WRITE (6,99003) Iter , F , Sbgnrm
      ENDIF
      IF ( Iprint.GE.1 ) WRITE (Itfile,99001) Iter , Nfgv , Nseg ,      &
                              & Nact , Word , Iback , Stp , Xstep ,     &
                              & Sbgnrm , F
99001 FORMAT (2(1x,i4),2(1x,i5),2x,a3,1x,i4,1p,2(2x,d7.1),1p,2(1x,d10.3)&
            & )
 
      CONTINUE
 
99002 FORMAT (/,a4,1p,6(1x,d11.4),/,(4x,1p,6(1x,d11.4)))
99003 FORMAT (/,'At iterate',i5,4x,'f= ',1p,d12.5,4x,'|proj g|= ',1p,   &
            & d12.5)
 
      END
 
!======================= The end of prn2lb =============================
 
      SUBROUTINE PRN3LB(N,X,F,Task,Iprint,Info,Itfile,Iter,Nfgv,Nintol, &
                      & Nskip,Nact,Sbgnrm,Time,Nseg,Word,Iback,Stp,     &
                      & Xstep,K,Cachyt,Sbtime,Lnscht)
      IMPLICIT NONE
!*--PRN3LB2843
 
      CHARACTER*60 Task
      CHARACTER*3 Word
      INTEGER N , Iprint , Info , Itfile , Iter , Nfgv , Nintol ,       &
            & Nskip , Nact , Nseg , Iback , K
      DOUBLE PRECISION F , Sbgnrm , Time , Stp , Xstep , Cachyt ,       &
                     & Sbtime , Lnscht , X(N)
 
!     ************
!
!     Subroutine prn3lb
!
!     This subroutine prints out information when either a built-in
!       convergence test is satisfied or when an error message is
!       generated.
!
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     ************
 
      INTEGER i
 
      IF ( Task(1:5).EQ.'ERROR' ) GOTO 100
 
      IF ( Iprint.GE.0 ) THEN
         WRITE (6,99001)
99001    FORMAT (/,'           * * *',/,/,                              &
                &'Tit   = total number of iterations',/,                &
                &'Tnf   = total number of function evaluations',/,      &
                &'Tnint = total number of segments explored during',    &
                &' Cauchy searches',/,                                  &
                &'Skip  = number of BFGS updates skipped',/,            &
                &'Nact  = number of active bounds at final generalized',&
                &' Cauchy point',/,                                     &
                &'Projg = norm of the final projected gradient',/,      &
                &'F     = final function value',/,/,'           * * *')
         WRITE (6,99002)
99002    FORMAT (/,3x,'N',4x,'Tit',5x,'Tnf',2x,'Tnint',2x,'Skip',2x,    &
                &'Nact',5x,'Projg',8x,'F')
         WRITE (6,99003) N , Iter , Nfgv , Nintol , Nskip , Nact ,      &
                       & Sbgnrm , F
99003    FORMAT (i5,2(1x,i6),(1x,i6),(2x,i4),(1x,i5),1p,2(2x,d10.3))
         IF ( Iprint.GE.100 ) THEN
            WRITE (6,99004) 'X =' , (X(i),i=1,N)
 
99004       FORMAT (/,a4,1p,6(1x,d11.4),/,(4x,1p,6(1x,d11.4)))
         ENDIF
         IF ( Iprint.GE.1 ) WRITE (6,*) ' F =' , F
      ENDIF
 100  CONTINUE
      IF ( Iprint.GE.0 ) THEN
         WRITE (6,99008) Task
         IF ( Info.NE.0 ) THEN
            IF ( Info.EQ.-1 ) WRITE (6,99009)
            IF ( Info.EQ.-2 ) WRITE (6,99010)
            IF ( Info.EQ.-3 ) WRITE (6,99011)
            IF ( Info.EQ.-4 ) WRITE (6,99012)
            IF ( Info.EQ.-5 ) WRITE (6,99013)
            IF ( Info.EQ.-6 ) WRITE (6,*) ' Input nbd(' , K ,           &
                                    &') is invalid.'
            IF ( Info.EQ.-7 ) WRITE (6,*) ' l(' , K , ') > u(' , K ,    &
                                    &').  No feasible solution.'
            IF ( Info.EQ.-8 ) WRITE (6,99014)
            IF ( Info.EQ.-9 ) WRITE (6,99015)
         ENDIF
         IF ( Iprint.GE.1 ) WRITE (6,99005) Cachyt , Sbtime , Lnscht
99005    FORMAT (/,' Cauchy                time',1p,e10.3,' seconds.',  &
                &/' Subspace minimization time',1p,e10.3,' seconds.',   &
                &/' Line search           time',1p,e10.3,' seconds.')
         WRITE (6,99007) Time
         IF ( Iprint.GE.1 ) THEN
            IF ( Info.EQ.-4 .OR. Info.EQ.-9 ) THEN
               WRITE (Itfile,99006) Iter , Nfgv , Nseg , Nact , Word ,  &
                                  & Iback , Stp , Xstep
99006          FORMAT (2(1x,i4),2(1x,i5),2x,a3,1x,i4,1p,2(2x,d7.1),6x,  &
                      &'-',10x,'-')
            ENDIF
            WRITE (Itfile,99008) Task
            IF ( Info.NE.0 ) THEN
               IF ( Info.EQ.-1 ) WRITE (Itfile,99009)
               IF ( Info.EQ.-2 ) WRITE (Itfile,99010)
               IF ( Info.EQ.-3 ) WRITE (Itfile,99011)
               IF ( Info.EQ.-4 ) WRITE (Itfile,99012)
               IF ( Info.EQ.-5 ) WRITE (Itfile,99013)
               IF ( Info.EQ.-8 ) WRITE (Itfile,99014)
               IF ( Info.EQ.-9 ) WRITE (Itfile,99015)
            ENDIF
            WRITE (Itfile,99007) Time
         ENDIF
      ENDIF
 
      CONTINUE
99007 FORMAT (/,' Total User time',1p,e10.3,' seconds.',/)
99008 FORMAT (/,a60)
99009 FORMAT (/,                                                        &
      &' Matrix in 1st Cholesky factorization in formk is not Pos. Def.'&
     & )
99010 FORMAT (/,                                                        &
      &' Matrix in 2st Cholesky factorization in formk is not Pos. Def.'&
     & )
99011 FORMAT (/,                                                        &
      &' Matrix in the Cholesky factorization in formt is not Pos. Def.'&
     & )
99012 FORMAT (/,' Derivative >= 0, backtracking line search impossible.'&
            & ,/,'   Previous x, f and g restored.',/,                  &
        &' Possible causes: 1 error in function or gradient evaluation;'&
       & ,/,'                  2 rounding errors dominate computation.')
99013 FORMAT (/,' Warning:  more than 10 function and gradient',/,      &
             &'   evaluations in the last line search.  Termination',/, &
             &'   may possibly be caused by a bad search direction.')
99014 FORMAT (/,' The triangular system is singular.')
99015 FORMAT (/,                                                        &
       &' Line search cannot locate an adequate point after 20 function'&
      & ,/,'  and gradient evaluations.  Previous x, f and g restored.',&
      & /,                                                              &
       &' Possible causes: 1 error in function or gradient evaluation;',&
      & /,'                  2 rounding error dominate computation.')
 
      END
 
!======================= The end of prn3lb =============================
 
      SUBROUTINE PROJGR(N,L,U,Nbd,X,G,Sbgnrm)
      IMPLICIT NONE
!*--PROJGR2978
 
      INTEGER N , Nbd(N)
      DOUBLE PRECISION Sbgnrm , X(N) , L(N) , U(N) , G(N)
 
!     ************
!
!     Subroutine projgr
!
!     This subroutine computes the infinity norm of the projected
!       gradient.
!
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     ************
 
      INTEGER i
      DOUBLE PRECISION gi
      DOUBLE PRECISION ZERO
      PARAMETER (ZERO=0.0D0)
 
      Sbgnrm = ZERO
      DO i = 1 , N
         gi = G(i)
         IF ( Nbd(i).NE.0 ) THEN
            IF ( gi.LT.ZERO ) THEN
               IF ( Nbd(i).GE.2 ) gi = MAX((X(i)-U(i)),gi)
            ELSE
               IF ( Nbd(i).LE.2 ) gi = MIN((X(i)-L(i)),gi)
            ENDIF
         ENDIF
         Sbgnrm = MAX(Sbgnrm,ABS(gi))
      ENDDO
 
      CONTINUE
 
      END
 
!======================= The end of projgr =============================
 
      SUBROUTINE SUBSM(N,M,Nsub,Ind,L,U,Nbd,X,D,Xp,Ws,Wy,Theta,Xx,Gg,   &
                     & Col,Head,Iword,Wv,Wn,Iprint,Info)
      IMPLICIT NONE
!*--SUBSM3031
      INTEGER N , M , Nsub , Col , Head , Iword , Iprint , Info ,       &
            & Ind(Nsub) , Nbd(N)
      DOUBLE PRECISION Theta , L(N) , U(N) , X(N) , D(N) , Xp(N) ,      &
                     & Xx(N) , Gg(N) , Ws(N,M) , Wy(N,M) , Wv(2*M) ,    &
                     & Wn(2*M,2*M)
 
!     **********************************************************************
!
!     This routine contains the major changes in the updated version.
!     The changes are described in the accompanying paper
!
!      Jose Luis Morales, Jorge Nocedal
!      "Remark On Algorithm 788: L-BFGS-B: Fortran Subroutines for Large-Scale
!       Bound Constrained Optimization". Decemmber 27, 2010.
!
!             J.L. Morales  Departamento de Matematicas,
!                           Instituto Tecnologico Autonomo de Mexico
!                           Mexico D.F.
!
!             J, Nocedal    Department of Electrical Engineering and
!                           Computer Science.
!                           Northwestern University. Evanston, IL. USA
!
!                           January 17, 2011
!
!      **********************************************************************
!
!
!     Subroutine subsm
!
!     Given xcp, l, u, r, an index set that specifies
!       the active set at xcp, and an l-BFGS matrix B
!       (in terms of WY, WS, SY, WT, head, col, and theta),
!       this subroutine computes an approximate solution
!       of the subspace problem
!
!       (P)   min Q(x) = r'(x-xcp) + 1/2 (x-xcp)' B (x-xcp)
!
!             subject to l<=x<=u
!                       x_i=xcp_i for all i in A(xcp)
!
!       along the subspace unconstrained Newton direction
!
!          d = -(Z'BZ)^(-1) r.
!
!       The formula for the Newton direction, given the L-BFGS matrix
!       and the Sherman-Morrison formula, is
!
!          d = (1/theta)r + (1/theta*2) Z'WK^(-1)W'Z r.
!
!       where
!                 K = [-D -Y'ZZ'Y/theta     L_a'-R_z'  ]
!                     [L_a -R_z           theta*S'AA'S ]
!
!     Note that this procedure for computing d differs
!     from that described in [1]. One can show that the matrix K is
!     equal to the matrix M^[-1]N in that paper.
!
!     n is an integer variable.
!       On entry n is the dimension of the problem.
!       On exit n is unchanged.
!
!     m is an integer variable.
!       On entry m is the maximum number of variable metric corrections
!         used to define the limited memory matrix.
!       On exit m is unchanged.
!
!     nsub is an integer variable.
!       On entry nsub is the number of free variables.
!       On exit nsub is unchanged.
!
!     ind is an integer array of dimension nsub.
!       On entry ind specifies the coordinate indices of free variables.
!       On exit ind is unchanged.
!
!     l is a double precision array of dimension n.
!       On entry l is the lower bound of x.
!       On exit l is unchanged.
!
!     u is a double precision array of dimension n.
!       On entry u is the upper bound of x.
!       On exit u is unchanged.
!
!     nbd is a integer array of dimension n.
!       On entry nbd represents the type of bounds imposed on the
!         variables, and must be specified as follows:
!         nbd(i)=0 if x(i) is unbounded,
!                1 if x(i) has only a lower bound,
!                2 if x(i) has both lower and upper bounds, and
!                3 if x(i) has only an upper bound.
!       On exit nbd is unchanged.
!
!     x is a double precision array of dimension n.
!       On entry x specifies the Cauchy point xcp.
!       On exit x(i) is the minimizer of Q over the subspace of
!                                                        free variables.
!
!     d is a double precision array of dimension n.
!       On entry d is the reduced gradient of Q at xcp.
!       On exit d is the Newton direction of Q.
!
!    xp is a double precision array of dimension n.
!       used to safeguard the projected Newton direction
!
!    xx is a double precision array of dimension n
!       On entry it holds the current iterate
!       On output it is unchanged
 
!    gg is a double precision array of dimension n
!       On entry it holds the gradient at the current iterate
!       On output it is unchanged
!
!     ws and wy are double precision arrays;
!     theta is a double precision variable;
!     col is an integer variable;
!     head is an integer variable.
!       On entry they store the information defining the
!                                          limited memory BFGS matrix:
!         ws(n,m) stores S, a set of s-vectors;
!         wy(n,m) stores Y, a set of y-vectors;
!         theta is the scaling factor specifying B_0 = theta I;
!         col is the number of variable metric corrections stored;
!         head is the location of the 1st s- (or y-) vector in S (or Y).
!       On exit they are unchanged.
!
!     iword is an integer variable.
!       On entry iword is unspecified.
!       On exit iword specifies the status of the subspace solution.
!         iword = 0 if the solution is in the box,
!                 1 if some bound is encountered.
!
!     wv is a double precision working array of dimension 2m.
!
!     wn is a double precision array of dimension 2m x 2m.
!       On entry the upper triangle of wn stores the LEL^T factorization
!         of the indefinite matrix
!
!              K = [-D -Y'ZZ'Y/theta     L_a'-R_z'  ]
!                  [L_a -R_z           theta*S'AA'S ]
!                                                    where E = [-I  0]
!                                                              [ 0  I]
!       On exit wn is unchanged.
!
!     iprint is an INTEGER variable that must be set by the user.
!       It controls the frequency and type of output generated:
!        iprint<0    no output is generated;
!        iprint=0    print only one line at the last iteration;
!        0<iprint<99 print also f and |proj g| every iprint iterations;
!        iprint=99   print details of every iteration except n-vectors;
!        iprint=100  print also the changes of active set and final x;
!        iprint>100  print details of every iteration including x and g;
!       When iprint > 0, the file iterate.dat will be created to
!                        summarize the iteration.
!
!     info is an integer variable.
!       On entry info is unspecified.
!       On exit info = 0       for normal return,
!                    = nonzero for abnormal return
!                                  when the matrix K is ill-conditioned.
!
!     Subprograms called:
!
!       Linpack dtrsl.
!
!
!     References:
!
!       [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited
!       memory algorithm for bound constrained optimization'',
!       SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208.
!
!
!
!                           *  *  *
!
!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
!
!
!     ************
 
      INTEGER pointr , m2 , col2 , ibd , jy , js , i , j , k
      DOUBLE PRECISION alpha , xk , dk , temp1 , temp2
      DOUBLE PRECISION ONE , ZERO
      PARAMETER (ONE=1.0D0,ZERO=0.0D0)
!
      DOUBLE PRECISION dd_p
 
      IF ( Nsub.LE.0 ) RETURN
      IF ( Iprint.GE.99 ) WRITE (6,99001)
 
99001 FORMAT (/,'----------------SUBSM entered-----------------',/)
 
!     Compute wv = W'Zd.
 
      pointr = Head
      DO i = 1 , Col
         temp1 = ZERO
         temp2 = ZERO
         DO j = 1 , Nsub
            k = Ind(j)
            temp1 = temp1 + Wy(k,pointr)*D(j)
            temp2 = temp2 + Ws(k,pointr)*D(j)
         ENDDO
         Wv(i) = temp1
         Wv(Col+i) = Theta*temp2
         pointr = MOD(pointr,M) + 1
      ENDDO
 
!     Compute wv:=K^(-1)wv.
 
      m2 = 2*M
      col2 = 2*Col
      CALL DTRSL(Wn,m2,col2,Wv,11,Info)
      IF ( Info.NE.0 ) RETURN
      DO i = 1 , Col
         Wv(i) = -Wv(i)
      ENDDO
      CALL DTRSL(Wn,m2,col2,Wv,01,Info)
      IF ( Info.NE.0 ) RETURN
 
!     Compute d = (1/theta)d + (1/theta**2)Z'W wv.
 
      pointr = Head
      DO jy = 1 , Col
         js = Col + jy
         DO i = 1 , Nsub
            k = Ind(i)
            D(i) = D(i) + Wy(k,pointr)*Wv(jy)/Theta + Ws(k,pointr)      &
                 & *Wv(js)
         ENDDO
         pointr = MOD(pointr,M) + 1
      ENDDO
 
      CALL DSCAL(Nsub,ONE/Theta,D,1)
!
!-----------------------------------------------------------------
!     Let us try the projection, d is the Newton direction
 
      Iword = 0
 
      CALL DCOPY(N,X,1,Xp,1)
!
      DO i = 1 , Nsub
         k = Ind(i)
         dk = D(i)
         xk = X(k)
         IF ( Nbd(k).NE.0 ) THEN
!
            IF ( Nbd(k).EQ.1 ) THEN          ! lower bounds only
               X(k) = MAX(L(k),xk+dk)
               IF ( X(k).EQ.L(k) ) Iword = 1
            ELSE
!
               IF ( Nbd(k).EQ.2 ) THEN       ! upper and lower bounds
                  xk = MAX(L(k),xk+dk)
                  X(k) = MIN(U(k),xk)
                  IF ( X(k).EQ.L(k) .OR. X(k).EQ.U(k) ) Iword = 1
               ELSE
!
                  IF ( Nbd(k).EQ.3 ) THEN    ! upper bounds only
                     X(k) = MIN(U(k),xk+dk)
                     IF ( X(k).EQ.U(k) ) Iword = 1
                  ENDIF
               ENDIF
            ENDIF
!
         ELSE                                ! free variables
            X(k) = xk + dk
         ENDIF
      ENDDO
!
      IF ( Iword.EQ.0 ) GOTO 100
!
!     check sign of the directional derivative
!
      dd_p = ZERO
      DO i = 1 , N
         dd_p = dd_p + (X(i)-Xx(i))*Gg(i)
      ENDDO
      IF ( dd_p.GT.ZERO ) THEN
         CALL DCOPY(N,Xp,1,X,1)
         WRITE (6,*) ' Positive dir derivative in projection '
         WRITE (6,*) ' Using the backtracking step '
      ELSE
         GOTO 100
      ENDIF
!
!-----------------------------------------------------------------
!
      alpha = ONE
      temp1 = alpha
      ibd = 0
      DO i = 1 , Nsub
         k = Ind(i)
         dk = D(i)
         IF ( Nbd(k).NE.0 ) THEN
            IF ( dk.LT.ZERO .AND. Nbd(k).LE.2 ) THEN
               temp2 = L(k) - X(k)
               IF ( temp2.GE.ZERO ) THEN
                  temp1 = ZERO
               ELSEIF ( dk*alpha.LT.temp2 ) THEN
                  temp1 = temp2/dk
               ENDIF
            ELSEIF ( dk.GT.ZERO .AND. Nbd(k).GE.2 ) THEN
               temp2 = U(k) - X(k)
               IF ( temp2.LE.ZERO ) THEN
                  temp1 = ZERO
               ELSEIF ( dk*alpha.GT.temp2 ) THEN
                  temp1 = temp2/dk
               ENDIF
            ENDIF
            IF ( temp1.LT.alpha ) THEN
               alpha = temp1
               ibd = i
            ENDIF
         ENDIF
      ENDDO
 
      IF ( alpha.LT.ONE ) THEN
         dk = D(ibd)
         k = Ind(ibd)
         IF ( dk.GT.ZERO ) THEN
            X(k) = U(k)
            D(ibd) = ZERO
         ELSEIF ( dk.LT.ZERO ) THEN
            X(k) = L(k)
            D(ibd) = ZERO
         ENDIF
      ENDIF
      DO i = 1 , Nsub
         k = Ind(i)
         X(k) = X(k) + alpha*D(i)
      ENDDO
!ccccc
 100  CONTINUE
 
      IF ( Iprint.GE.99 ) WRITE (6,99002)
99002 FORMAT (/,'----------------exit SUBSM --------------------',/)
 
      CONTINUE
 
      END
!====================== The end of subsm ===============================
 
      SUBROUTINE DCSRCH(F,G,Stp,Ftol,Gtol,Xtol,Stpmin,Stpmax,Task,Isave,&
                      & Dsave)
      IMPLICIT NONE
!*--DCSRCH3385
      CHARACTER*(*) Task
      INTEGER Isave(2)
      DOUBLE PRECISION F , G , Stp , Ftol , Gtol , Xtol , Stpmin ,      &
                     & Stpmax
      DOUBLE PRECISION Dsave(13)
!     **********
!
!     Subroutine dcsrch
!
!     This subroutine finds a step that satisfies a sufficient
!     decrease condition and a curvature condition.
!
!     Each call of the subroutine updates an interval with
!     endpoints stx and sty. The interval is initially chosen
!     so that it contains a minimizer of the modified function
!
!           psi(stp) = f(stp) - f(0) - ftol*stp*f'(0).
!
!     If psi(stp) <= 0 and f'(stp) >= 0 for some step, then the
!     interval is chosen so that it contains a minimizer of f.
!
!     The algorithm is designed to find a step that satisfies
!     the sufficient decrease condition
!
!           f(stp) <= f(0) + ftol*stp*f'(0),
!
!     and the curvature condition
!
!           abs(f'(stp)) <= gtol*abs(f'(0)).
!
!     If ftol is less than gtol and if, for example, the function
!     is bounded below, then there is always a step which satisfies
!     both conditions.
!
!     If no step can be found that satisfies both conditions, then
!     the algorithm stops with a warning. In this case stp only
!     satisfies the sufficient decrease condition.
!
!     A typical invocation of dcsrch has the following outline:
!
!     task = 'START'
!  10 continue
!        call dcsrch( ... )
!        if (task .eq. 'FG') then
!           Evaluate the function and the gradient at stp
!           goto 10
!           end if
!
!     NOTE: The user must no alter work arrays between calls.
!
!     The subroutine statement is
!
!        subroutine dcsrch(f,g,stp,ftol,gtol,xtol,stpmin,stpmax,
!                          task,isave,dsave)
!     where
!
!       f is a double precision variable.
!         On initial entry f is the value of the function at 0.
!            On subsequent entries f is the value of the
!            function at stp.
!         On exit f is the value of the function at stp.
!
!       g is a double precision variable.
!         On initial entry g is the derivative of the function at 0.
!            On subsequent entries g is the derivative of the
!            function at stp.
!         On exit g is the derivative of the function at stp.
!
!       stp is a double precision variable.
!         On entry stp is the current estimate of a satisfactory
!            step. On initial entry, a positive initial estimate
!            must be provided.
!         On exit stp is the current estimate of a satisfactory step
!            if task = 'FG'. If task = 'CONV' then stp satisfies
!            the sufficient decrease and curvature condition.
!
!       ftol is a double precision variable.
!         On entry ftol specifies a nonnegative tolerance for the
!            sufficient decrease condition.
!         On exit ftol is unchanged.
!
!       gtol is a double precision variable.
!         On entry gtol specifies a nonnegative tolerance for the
!            curvature condition.
!         On exit gtol is unchanged.
!
!       xtol is a double precision variable.
!         On entry xtol specifies a nonnegative relative tolerance
!            for an acceptable step. The subroutine exits with a
!            warning if the relative difference between sty and stx
!            is less than xtol.
!         On exit xtol is unchanged.
!
!       stpmin is a double precision variable.
!         On entry stpmin is a nonnegative lower bound for the step.
!         On exit stpmin is unchanged.
!
!       stpmax is a double precision variable.
!         On entry stpmax is a nonnegative upper bound for the step.
!         On exit stpmax is unchanged.
!
!       task is a character variable of length at least 60.
!         On initial entry task must be set to 'START'.
!         On exit task indicates the required action:
!
!            If task(1:2) = 'FG' then evaluate the function and
!            derivative at stp and call dcsrch again.
!
!            If task(1:4) = 'CONV' then the search is successful.
!
!            If task(1:4) = 'WARN' then the subroutine is not able
!            to satisfy the convergence conditions. The exit value of
!            stp contains the best point found during the search.
!
!            If task(1:5) = 'ERROR' then there is an error in the
!            input arguments.
!
!         On exit with convergence, a warning or an error, the
!            variable task contains additional information.
!
!       isave is an integer work array of dimension 2.
!
!       dsave is a double precision work array of dimension 13.
!
!     Subprograms called
!
!       MINPACK-2 ... dcstep
!
!     MINPACK-1 Project. June 1983.
!     Argonne National Laboratory.
!     Jorge J. More' and David J. Thuente.
!
!     MINPACK-2 Project. October 1993.
!     Argonne National Laboratory and University of Minnesota.
!     Brett M. Averick, Richard G. Carter, and Jorge J. More'.
!
!     **********
      DOUBLE PRECISION ZERO , P5 , P66
      PARAMETER (ZERO=0.0D0,P5=0.5D0,P66=0.66D0)
      DOUBLE PRECISION XTRAPL , XTRAPU
      PARAMETER (XTRAPL=1.1D0,XTRAPU=4.0D0)
 
      LOGICAL brackt
      INTEGER stage
      DOUBLE PRECISION finit , ftest , fm , fx , fxm , fy , fym ,       &
                     & ginit , gtest , gm , gx , gxm , gy , gym , stx , &
                     & sty , stmin , stmax , width , width1
 
!     Initialization block.
 
      IF ( Task(1:5).EQ.'START' ) THEN
 
!        Check the input arguments for errors.
 
         IF ( Stp.LT.Stpmin ) Task = 'ERROR: STP .LT. STPMIN'
         IF ( Stp.GT.Stpmax ) Task = 'ERROR: STP .GT. STPMAX'
         IF ( G.GE.ZERO ) Task = 'ERROR: INITIAL G .GE. ZERO'
         IF ( Ftol.LT.ZERO ) Task = 'ERROR: FTOL .LT. ZERO'
         IF ( Gtol.LT.ZERO ) Task = 'ERROR: GTOL .LT. ZERO'
         IF ( Xtol.LT.ZERO ) Task = 'ERROR: XTOL .LT. ZERO'
         IF ( Stpmin.LT.ZERO ) Task = 'ERROR: STPMIN .LT. ZERO'
         IF ( Stpmax.LT.Stpmin ) Task = 'ERROR: STPMAX .LT. STPMIN'
 
!        Exit if there are errors on input.
 
         IF ( Task(1:5).EQ.'ERROR' ) RETURN
 
!        Initialize local variables.
 
         brackt = .FALSE.
         stage = 1
         finit = F
         ginit = G
         gtest = Ftol*ginit
         width = Stpmax - Stpmin
         width1 = width/P5
 
!        The variables stx, fx, gx contain the values of the step,
!        function, and derivative at the best step.
!        The variables sty, fy, gy contain the value of the step,
!        function, and derivative at sty.
!        The variables stp, f, g contain the values of the step,
!        function, and derivative at stp.
 
         stx = ZERO
         fx = finit
         gx = ginit
         sty = ZERO
         fy = finit
         gy = ginit
         stmin = ZERO
         stmax = Stp + XTRAPU*Stp
         Task = 'FG'
 
         GOTO 100
 
      ELSE
 
!        Restore local variables.
 
         IF ( Isave(1).EQ.1 ) THEN
            brackt = .TRUE.
         ELSE
            brackt = .FALSE.
         ENDIF
         stage = Isave(2)
         ginit = Dsave(1)
         gtest = Dsave(2)
         gx = Dsave(3)
         gy = Dsave(4)
         finit = Dsave(5)
         fx = Dsave(6)
         fy = Dsave(7)
         stx = Dsave(8)
         sty = Dsave(9)
         stmin = Dsave(10)
         stmax = Dsave(11)
         width = Dsave(12)
         width1 = Dsave(13)
 
      ENDIF
 
!     If psi(stp) <= 0 and f'(stp) >= 0 for some step, then the
!     algorithm enters the second stage.
 
      ftest = finit + Stp*gtest
      IF ( stage.EQ.1 .AND. F.LE.ftest .AND. G.GE.ZERO ) stage = 2
 
!     Test for warnings.
 
      IF ( brackt .AND. (Stp.LE.stmin .OR. Stp.GE.stmax) )              &
          & Task = 'WARNING: ROUNDING ERRORS PREVENT PROGRESS'
      IF ( brackt .AND. stmax-stmin.LE.Xtol*stmax )                     &
          & Task = 'WARNING: XTOL TEST SATISFIED'
      IF ( Stp.EQ.Stpmax .AND. F.LE.ftest .AND. G.LE.gtest )            &
          & Task = 'WARNING: STP = STPMAX'
      IF ( Stp.EQ.Stpmin .AND. (F.GT.ftest .OR. G.GE.gtest) )           &
          & Task = 'WARNING: STP = STPMIN'
 
!     Test for convergence.
 
      IF ( F.LE.ftest .AND. ABS(G).LE.Gtol*(-ginit) )                   &
          & Task = 'CONVERGENCE'
 
!     Test for termination.
 
      IF ( Task(1:4).EQ.'WARN' .OR. Task(1:4).EQ.'CONV' ) GOTO 100
 
!     A modified function is used to predict the step during the
!     first stage if a lower function value has been obtained but
!     the decrease is not sufficient.
 
      IF ( stage.EQ.1 .AND. F.LE.fx .AND. F.GT.ftest ) THEN
 
!        Define the modified function and derivative values.
 
         fm = F - Stp*gtest
         fxm = fx - stx*gtest
         fym = fy - sty*gtest
         gm = G - gtest
         gxm = gx - gtest
         gym = gy - gtest
 
!        Call dcstep to update stx, sty, and to compute the new step.
 
         CALL DCSTEP(stx,fxm,gxm,sty,fym,gym,Stp,fm,gm,brackt,stmin,    &
                   & stmax)
 
!        Reset the function and derivative values for f.
 
         fx = fxm + stx*gtest
         fy = fym + sty*gtest
         gx = gxm + gtest
         gy = gym + gtest
 
      ELSE
 
!       Call dcstep to update stx, sty, and to compute the new step.
 
         CALL DCSTEP(stx,fx,gx,sty,fy,gy,Stp,F,G,brackt,stmin,stmax)
 
      ENDIF
 
!     Decide if a bisection step is needed.
 
      IF ( brackt ) THEN
         IF ( ABS(sty-stx).GE.P66*width1 ) Stp = stx + P5*(sty-stx)
         width1 = width
         width = ABS(sty-stx)
      ENDIF
 
!     Set the minimum and maximum steps allowed for stp.
 
      IF ( brackt ) THEN
         stmin = MIN(stx,sty)
         stmax = MAX(stx,sty)
      ELSE
         stmin = Stp + XTRAPL*(Stp-stx)
         stmax = Stp + XTRAPU*(Stp-stx)
      ENDIF
 
!     Force the step to be within the bounds stpmax and stpmin.
 
      Stp = MAX(Stp,Stpmin)
      Stp = MIN(Stp,Stpmax)
 
!     If further progress is not possible, let stp be the best
!     point obtained during the search.
 
      IF ( brackt .AND. (Stp.LE.stmin .OR. Stp.GE.stmax) .OR.           &
         & (brackt .AND. stmax-stmin.LE.Xtol*stmax) ) Stp = stx
 
!     Obtain another function and derivative.
 
      Task = 'FG'
 
 100  CONTINUE
 
!     Save local variables.
 
      IF ( brackt ) THEN
         Isave(1) = 1
      ELSE
         Isave(1) = 0
      ENDIF
      Isave(2) = stage
      Dsave(1) = ginit
      Dsave(2) = gtest
      Dsave(3) = gx
      Dsave(4) = gy
      Dsave(5) = finit
      Dsave(6) = fx
      Dsave(7) = fy
      Dsave(8) = stx
      Dsave(9) = sty
      Dsave(10) = stmin
      Dsave(11) = stmax
      Dsave(12) = width
      Dsave(13) = width1
 
      CONTINUE
      END
 
!====================== The end of dcsrch ==============================
 
      SUBROUTINE DCSTEP(Stx,Fx,Dx,Sty,Fy,Dy,Stp,Fp,Dp,Brackt,Stpmin,    &
                      & Stpmax)
      IMPLICIT NONE
!*--DCSTEP3735
      LOGICAL Brackt
      DOUBLE PRECISION Stx , Fx , Dx , Sty , Fy , Dy , Stp , Fp , Dp ,  &
                     & Stpmin , Stpmax
!     **********
!
!     Subroutine dcstep
!
!     This subroutine computes a safeguarded step for a search
!     procedure and updates an interval that contains a step that
!     satisfies a sufficient decrease and a curvature condition.
!
!     The parameter stx contains the step with the least function
!     value. If brackt is set to .true. then a minimizer has
!     been bracketed in an interval with endpoints stx and sty.
!     The parameter stp contains the current step.
!     The subroutine assumes that if brackt is set to .true. then
!
!           min(stx,sty) < stp < max(stx,sty),
!
!     and that the derivative at stx is negative in the direction
!     of the step.
!
!     The subroutine statement is
!
!       subroutine dcstep(stx,fx,dx,sty,fy,dy,stp,fp,dp,brackt,
!                         stpmin,stpmax)
!
!     where
!
!       stx is a double precision variable.
!         On entry stx is the best step obtained so far and is an
!            endpoint of the interval that contains the minimizer.
!         On exit stx is the updated best step.
!
!       fx is a double precision variable.
!         On entry fx is the function at stx.
!         On exit fx is the function at stx.
!
!       dx is a double precision variable.
!         On entry dx is the derivative of the function at
!            stx. The derivative must be negative in the direction of
!            the step, that is, dx and stp - stx must have opposite
!            signs.
!         On exit dx is the derivative of the function at stx.
!
!       sty is a double precision variable.
!         On entry sty is the second endpoint of the interval that
!            contains the minimizer.
!         On exit sty is the updated endpoint of the interval that
!            contains the minimizer.
!
!       fy is a double precision variable.
!         On entry fy is the function at sty.
!         On exit fy is the function at sty.
!
!       dy is a double precision variable.
!         On entry dy is the derivative of the function at sty.
!         On exit dy is the derivative of the function at the exit sty.
!
!       stp is a double precision variable.
!         On entry stp is the current step. If brackt is set to .true.
!            then on input stp must be between stx and sty.
!         On exit stp is a new trial step.
!
!       fp is a double precision variable.
!         On entry fp is the function at stp
!         On exit fp is unchanged.
!
!       dp is a double precision variable.
!         On entry dp is the the derivative of the function at stp.
!         On exit dp is unchanged.
!
!       brackt is an logical variable.
!         On entry brackt specifies if a minimizer has been bracketed.
!            Initially brackt must be set to .false.
!         On exit brackt specifies if a minimizer has been bracketed.
!            When a minimizer is bracketed brackt is set to .true.
!
!       stpmin is a double precision variable.
!         On entry stpmin is a lower bound for the step.
!         On exit stpmin is unchanged.
!
!       stpmax is a double precision variable.
!         On entry stpmax is an upper bound for the step.
!         On exit stpmax is unchanged.
!
!     MINPACK-1 Project. June 1983
!     Argonne National Laboratory.
!     Jorge J. More' and David J. Thuente.
!
!     MINPACK-2 Project. October 1993.
!     Argonne National Laboratory and University of Minnesota.
!     Brett M. Averick and Jorge J. More'.
!
!     **********
      DOUBLE PRECISION ZERO , P66 , TWO , THREE
      PARAMETER (ZERO=0.0D0,P66=0.66D0,TWO=2.0D0,THREE=3.0D0)
 
      DOUBLE PRECISION gamma , p , q , r , s , sgnd , stpc , stpf ,     &
                     & stpq , theta
 
      sgnd = Dp*(Dx/ABS(Dx))
 
!     First case: A higher function value. The minimum is bracketed.
!     If the cubic step is closer to stx than the quadratic step, the
!     cubic step is taken, otherwise the average of the cubic and
!     quadratic steps is taken.
 
      IF ( Fp.GT.Fx ) THEN
         theta = THREE*(Fx-Fp)/(Stp-Stx) + Dx + Dp
         s = MAX(ABS(theta),ABS(Dx),ABS(Dp))
         gamma = s*SQRT((theta/s)**2-(Dx/s)*(Dp/s))
         IF ( Stp.LT.Stx ) gamma = -gamma
         p = (gamma-Dx) + theta
         q = ((gamma-Dx)+gamma) + Dp
         r = p/q
         stpc = Stx + r*(Stp-Stx)
         stpq = Stx + ((Dx/((Fx-Fp)/(Stp-Stx)+Dx))/TWO)*(Stp-Stx)
         IF ( ABS(stpc-Stx).LT.ABS(stpq-Stx) ) THEN
            stpf = stpc
         ELSE
            stpf = stpc + (stpq-stpc)/TWO
         ENDIF
         Brackt = .TRUE.
 
!     Second case: A lower function value and derivatives of opposite
!     sign. The minimum is bracketed. If the cubic step is farther from
!     stp than the secant step, the cubic step is taken, otherwise the
!     secant step is taken.
 
      ELSEIF ( sgnd.LT.ZERO ) THEN
         theta = THREE*(Fx-Fp)/(Stp-Stx) + Dx + Dp
         s = MAX(ABS(theta),ABS(Dx),ABS(Dp))
         gamma = s*SQRT((theta/s)**2-(Dx/s)*(Dp/s))
         IF ( Stp.GT.Stx ) gamma = -gamma
         p = (gamma-Dp) + theta
         q = ((gamma-Dp)+gamma) + Dx
         r = p/q
         stpc = Stp + r*(Stx-Stp)
         stpq = Stp + (Dp/(Dp-Dx))*(Stx-Stp)
         IF ( ABS(stpc-Stp).GT.ABS(stpq-Stp) ) THEN
            stpf = stpc
         ELSE
            stpf = stpq
         ENDIF
         Brackt = .TRUE.
 
!     Third case: A lower function value, derivatives of the same sign,
!     and the magnitude of the derivative decreases.
 
      ELSEIF ( ABS(Dp).LT.ABS(Dx) ) THEN
 
!        The cubic step is computed only if the cubic tends to infinity
!        in the direction of the step or if the minimum of the cubic
!        is beyond stp. Otherwise the cubic step is defined to be the
!        secant step.
 
         theta = THREE*(Fx-Fp)/(Stp-Stx) + Dx + Dp
         s = MAX(ABS(theta),ABS(Dx),ABS(Dp))
 
!        The case gamma = 0 only arises if the cubic does not tend
!        to infinity in the direction of the step.
 
         gamma = s*SQRT(MAX(ZERO,(theta/s)**2-(Dx/s)*(Dp/s)))
         IF ( Stp.GT.Stx ) gamma = -gamma
         p = (gamma-Dp) + theta
         q = (gamma+(Dx-Dp)) + gamma
         r = p/q
         IF ( r.LT.ZERO .AND. gamma.NE.ZERO ) THEN
            stpc = Stp + r*(Stx-Stp)
         ELSEIF ( Stp.GT.Stx ) THEN
            stpc = Stpmax
         ELSE
            stpc = Stpmin
         ENDIF
         stpq = Stp + (Dp/(Dp-Dx))*(Stx-Stp)
 
         IF ( Brackt ) THEN
 
!           A minimizer has been bracketed. If the cubic step is
!           closer to stp than the secant step, the cubic step is
!           taken, otherwise the secant step is taken.
 
            IF ( ABS(stpc-Stp).LT.ABS(stpq-Stp) ) THEN
               stpf = stpc
            ELSE
               stpf = stpq
            ENDIF
            IF ( Stp.GT.Stx ) THEN
               stpf = MIN(Stp+P66*(Sty-Stp),stpf)
            ELSE
               stpf = MAX(Stp+P66*(Sty-Stp),stpf)
            ENDIF
         ELSE
 
!           A minimizer has not been bracketed. If the cubic step is
!           farther from stp than the secant step, the cubic step is
!           taken, otherwise the secant step is taken.
 
            IF ( ABS(stpc-Stp).GT.ABS(stpq-Stp) ) THEN
               stpf = stpc
            ELSE
               stpf = stpq
            ENDIF
            stpf = MIN(Stpmax,stpf)
            stpf = MAX(Stpmin,stpf)
         ENDIF
 
!     Fourth case: A lower function value, derivatives of the same sign,
!     and the magnitude of the derivative does not decrease. If the
!     minimum is not bracketed, the step is either stpmin or stpmax,
!     otherwise the cubic step is taken.
 
      ELSE
         IF ( Brackt ) THEN
            theta = THREE*(Fp-Fy)/(Sty-Stp) + Dy + Dp
            s = MAX(ABS(theta),ABS(Dy),ABS(Dp))
            gamma = s*SQRT((theta/s)**2-(Dy/s)*(Dp/s))
            IF ( Stp.GT.Sty ) gamma = -gamma
            p = (gamma-Dp) + theta
            q = ((gamma-Dp)+gamma) + Dy
            r = p/q
            stpc = Stp + r*(Sty-Stp)
            stpf = stpc
         ELSEIF ( Stp.GT.Stx ) THEN
            stpf = Stpmax
         ELSE
            stpf = Stpmin
         ENDIF
      ENDIF
 
!     Update the interval which contains a minimizer.
 
      IF ( Fp.GT.Fx ) THEN
         Sty = Stp
         Fy = Fp
         Dy = Dp
      ELSE
         IF ( sgnd.LT.ZERO ) THEN
            Sty = Stx
            Fy = Fx
            Dy = Dx
         ENDIF
         Stx = Stp
         Fx = Fp
         Dx = Dp
      ENDIF
 
!     Compute the new step.
 
      Stp = stpf
 
      CONTINUE
      END
 
