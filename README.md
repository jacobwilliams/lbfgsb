![LBFGSB](media/logo.png)
============

This is a modern Fortran refactoring of the [Lbfgsb](http://users.iems.northwestern.edu/~nocedal/lbfgsb.html) limited memory code for solving bound constrained optimization problems [L-BFGS-B version 3.0, march, 2011].

**This is a work in progress.**

[![GitHub release](https://img.shields.io/github/release/jacobwilliams/lbfgsb.svg?style=plastic)](https://github.com/jacobwilliams/lbfgsb/releases/latest)
[![Build Status](https://github.com/jacobwilliams/lbfgsb/actions/workflows/CI.yml/badge.svg)](https://github.com/jacobwilliams/lbfgsb/actions)
[![codecov](https://codecov.io/gh/jacobwilliams/lbfgsb/branch/master/graph/badge.svg?token=BHtd51oUTE)](https://codecov.io/gh/jacobwilliams/lbfgsb)

### Documentation

  * The latest API documentation can be found [here](https://jacobwilliams.github.io/lbfgsb/). This was generated from the source code using [FORD](https://github.com/Fortran-FOSS-Programmers/ford) (i.e. by running `ford ford.md`).

  * The following four articles were also included in the original package:

     1. `algorithm.pdf`     -  describes the algorithm
     2. `compact.pdf`       -  presents the compact form of matrices
     3. `code.pdf`          -  describes the code
     4. `acm-remark.pdf`    -  describes the modification/correction

   The most useful articles for those who only wish to use the code
   are [3,4]. Users interested in understanding the algorithm should
   read [1] and possibly also [2].

### How to use L-BFGS-B

The simplest way to use the code is to modify one of the
drivers provided in the package.  Most users will only need to make
a few changes to the drivers to run their applications.

The user is required to calculate the function value `f` and its gradient `g`.
In order to allow the user complete control over these computations,
reverse communication is used.  The routine `setulb` must be called
repeatedly under the control of the variable task.  The calling
statement of L-BFGS-B is

```fortran
 call setulb(n,m,x,l,u,nbd,f,g,factr,pgtol,wa,iwa,task,iprint, csave,lsave,isave,dsave)
```

Following is a description of all the parameters used in this call.

```
     n is an INTEGER variable that must be set by the user to the
       number of variables.  It is not altered by the routine.

     m is an INTEGER variable that must be set by the user to the
       number of corrections used in the limited memory matrix.
       It is not altered by the routine.  Values of m < 3  are
       not recommended, and large values of m can result in excessive
       computing time. The range  3 <= m <= 20 is recommended.

     x is a DOUBLE PRECISION array of length n.  On initial entry
       it must be set by the user to the values of the initial
       estimate of the solution vector.  Upon successful exit, it
       contains the values of the variables at the best point
       found (usually an approximate solution).

     l is a DOUBLE PRECISION array of length n that must be set by
       the user to the values of the lower bounds on the variables. If
       the i-th variable has no lower bound, l(i) need not be defined.

     u is a DOUBLE PRECISION array of length n that must be set by
       the user to the values of the upper bounds on the variables. If
       the i-th variable has no upper bound, u(i) need not be defined.

     nbd is an INTEGER array of dimension n that must be set by the
       user to the type of bounds imposed on the variables:
       nbd(i)=0 if x(i) is unbounded,
              1 if x(i) has only a lower bound,
              2 if x(i) has both lower and upper bounds,
              3 if x(i) has only an upper bound.

     f is a DOUBLE PRECISION variable.  If the routine setulb returns
       with task(1:2)= 'FG', then f must be set by the user to
       contain the value of the function at the point x.

     g is a DOUBLE PRECISION array of length n.  If the routine setulb
       returns with taskb(1:2)= 'FG', then g must be set by the user to
       contain the components of the gradient at the point x.

     factr is a DOUBLE PRECISION variable that must be set by the user.
       It is a tolerance in the termination test for the algorithm.
       The iteration will stop when

        (f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} <= factr*epsmch

       where epsmch is the machine precision which is automatically
       generated by the code. Typical values for factr on a computer
       with 15 digits of accuracy in double precision are:
       factr=1.d+12 for low accuracy;
             1.d+7  for moderate accuracy;
             1.d+1  for extremely high accuracy.
       The user can suppress this termination test by setting factr=0.

     pgtol is a double precision variable.
       On entry pgtol >= 0 is specified by the user.  The iteration
         will stop when

                 max{|proj g_i | i = 1, ..., n} <= pgtol

         where pg_i is the ith component of the projected gradient.
       The user can suppress this termination test by setting pgtol=0.

     wa is a DOUBLE PRECISION  array of length
       (2mmax + 5)nmax + 11mmax^2 + 8mmax used as workspace.
       This array must not be altered by the user.

     iwa is an INTEGER  array of length 3nmax used as
       workspace. This array must not be altered by the user.

     task is a CHARACTER string of length 60.
       On first entry, it must be set to 'START'.
       On a return with task(1:2)='FG', the user must evaluate the
         function f and gradient g at the returned value of x.
       On a return with task(1:5)='NEW_X', an iteration of the
         algorithm has concluded, and f and g contain f(x) and g(x)
         respectively.  The user can decide whether to continue or stop
         the iteration.
       When
         task(1:4)='CONV', the termination test in L-BFGS-B has been
           satisfied;
         task(1:4)='ABNO', the routine has terminated abnormally
           without being able to satisfy the termination conditions,
           x contains the best approximation found,
           f and g contain f(x) and g(x) respectively;
         task(1:5)='ERROR', the routine has detected an error in the
           input parameters;
       On exit with task = 'CONV', 'ABNO' or 'ERROR', the variable task
         contains additional information that the user can print.
       This array should not be altered unless the user wants to
          stop the run for some reason.  See driver2 or driver3
          for a detailed explanation on how to stop the run
          by assigning task(1:4)='STOP' in the driver.

     iprint is an INTEGER variable that must be set by the user.
       It controls the frequency and type of output generated:
        iprint<0    no output is generated;
        iprint=0    print only one line at the last iteration;
        0<iprint<99 print also f and |proj g| every iprint iterations;
        iprint=99   print details of every iteration except n-vectors;
        iprint=100  print also the changes of active set and final x;
        iprint>100  print details of every iteration including x and g;
       When iprint > 0, the file iterate.dat will be created to
                        summarize the iteration.

     csave  is a CHARACTER working array of length 60.

     lsave is a LOGICAL working array of dimension 4.
       On exit with task = 'NEW_X', the following information is
         available:
       lsave(1) = .true.  the initial x did not satisfy the bounds;
       lsave(2) = .true.  the problem contains bounds;
       lsave(3) = .true.  each variable has upper and lower bounds.

     isave is an INTEGER working array of dimension 44.
       On exit with task = 'NEW_X', it contains information that
       the user may want to access:
         isave(30) = the current iteration number;
         isave(34) = the total number of function and gradient
                         evaluations;
         isave(36) = the number of function value or gradient
                                  evaluations in the current iteration;
         isave(38) = the number of free variables in the current
                         iteration;
         isave(39) = the number of active constraints at the current
                         iteration;

         see the subroutine setulb.f for a description of other
         information contained in isave

     dsave is a DOUBLE PRECISION working array of dimension 29.
       On exit with task = 'NEW_X', it contains information that
         the user may want to access:
         dsave(2) = the value of f at the previous iteration;
         dsave(5) = the machine precision epsmch generated by the code;
         dsave(13) = the infinity norm of the projected gradient;

         see the subroutine setulb.f for a description of other
         information contained in dsave
```

### License

L-BFGS-B is released under the "New BSD License" (aka "Modified BSD License" or
"3-clause license")
Please read attached file License.txt

### References

* R. H. Byrd, P. Lu and J. Nocedal. [A Limited Memory Algorithm for Bound Constrained Optimization](http://www.ece.northwestern.edu/~nocedal/PSfiles/limited.ps.gz), (1995), SIAM Journal on Scientific and Statistical Computing , 16, 5, pp. 1190-1208.
* C. Zhu, R. H. Byrd and J. Nocedal. [L-BFGS-B: Algorithm 778: L-BFGS-B, FORTRAN routines for large scale bound constrained optimization](http://www.ece.northwestern.edu/~nocedal/PSfiles/lbfgsb.ps.gz) (1997), ACM Transactions on Mathematical Software, Vol 23, Num. 4, pp. 550 - 560.
* J.L. Morales and J. Nocedal. [L-BFGS-B: Remark on Algorithm 778: L-BFGS-B, FORTRAN routines for large scale bound constrained optimization](http://www.ece.northwestern.edu/~morales/PSfiles/acm-remark.pdf) (2011), ACM Transactions on Mathematical Software, Volume 38, Issue 1, No. 7, pp 1 - 4.

